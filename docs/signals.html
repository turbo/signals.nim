<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>signals</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.2">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.2"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">signals</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">ðŸŒ— Match OS</option>
        <option value="dark">ðŸŒ‘ Dark</option>
        <option value="light">ðŸŒ• Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a id="indexLink" href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" oninput="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="signals-minus-durable-reactive-effects-for-nim_toc" href="#signals-minus-durable-reactive-effects-for-nim">Signals - Durable Reactive Effects for Nim</a></li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#7" id="57">Types</a></summary>
    <ul class="simple simple-toc-section">
      <li><a class="reference" href="#AddCleanup" title="AddCleanup = proc (c: Cleanup)">AddCleanup</a></li>
<li><a class="reference" href="#Cleanup" title="Cleanup = proc ()">Cleanup</a></li>
<li><a class="reference" href="#HistoryEntry" title="HistoryEntry = tuple[undo, redo: proc ()]">HistoryEntry</a></li>
<li><a class="reference" href="#ReactiveCtx" title="ReactiveCtx = ref object">ReactiveCtx</a></li>
<li><a class="reference" href="#ReactiveSeq" title="ReactiveSeq[T] = ref object">ReactiveSeq</a></li>
<li><a class="reference" href="#ReactiveTable" title="ReactiveTable[K; V] = ref object">ReactiveTable</a></li>
<li><a class="reference" href="#Signal" title="Signal[T] = ref object">Signal</a></li>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#12" id="62">Procs</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">==
  <li><a class="reference" href="#%3D%3D%2CReactiveTable%5BK%2CV%5D%2CTable%5BK%2CV%5D" title="`==`[K, V](a: ReactiveTable[K, V]; b: Table[K, V]): bool">`==`[K, V](a: ReactiveTable[K, V]; b: Table[K, V]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2CTable%5BK%2CV%5D%2CReactiveTable%5BK%2CV%5D" title="`==`[K, V](a: Table[K, V]; b: ReactiveTable[K, V]): bool">`==`[K, V](a: Table[K, V]; b: ReactiveTable[K, V]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2CReactiveSeq%5BT%5D%2Cseq%5BT%5D" title="`==`[T](a: ReactiveSeq[T]; b: seq[T]): bool">`==`[T](a: ReactiveSeq[T]; b: seq[T]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2Cseq%5BSignal%5BT%5D%5D%2Cseq%5BT%5D" title="`==`[T](a: seq[Signal[T]]; b: seq[T]): bool">`==`[T](a: seq[Signal[T]]; b: seq[T]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2Cseq%5BT%5D%2CReactiveSeq%5BT%5D" title="`==`[T](a: seq[T]; b: ReactiveSeq[T]): bool">`==`[T](a: seq[T]; b: ReactiveSeq[T]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2Cseq%5BT%5D%2Cseq%5BSignal%5BT%5D%5D" title="`==`[T](a: seq[T]; b: seq[Signal[T]]): bool">`==`[T](a: seq[T]; b: seq[Signal[T]]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2Cseq%5BT%5D%2CSignal%5Bseq%5BT%5D%5D" title="`==`[T](a: seq[T]; b: Signal[seq[T]]): bool">`==`[T](a: seq[T]; b: Signal[seq[T]]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2CSignal%5Bseq%5BT%5D%5D%2Cseq%5BT%5D" title="`==`[T](a: Signal[seq[T]]; b: seq[T]): bool">`==`[T](a: Signal[seq[T]]; b: seq[T]): bool</a></li>
<li><a class="reference" href="#%3D%3D%2CSignal%5BT%5D%2CT" title="`==`[T](a: Signal[T]; b: T): bool">`==`[T](a: Signal[T]; b: T): bool</a></li>
<li><a class="reference" href="#%3D%3D%2CT%2CSignal%5BT%5D" title="`==`[T](a: T; b: Signal[T]): bool">`==`[T](a: T; b: Signal[T]): bool</a></li>

</ul>
<ul class="simple nested-toc-section">[]
  <li><a class="reference" href="#%5B%5D%2CReactiveTable%5BK%2CV%5D%2CK" title="`[]`[K, V](rt: ReactiveTable[K, V]; key: K): Signal[V]">`[]`[K, V](rt: ReactiveTable[K, V]; key: K): Signal[V]</a></li>

</ul>
<ul class="simple nested-toc-section">[]=
  <li><a class="reference" href="#%5B%5D%3D%2CReactiveTable%5BK%2CV%5D%2CK%2CV" title="`[]=`[K, V](rt: ReactiveTable[K, V]; key: K; val: V)">`[]=`[K, V](rt: ReactiveTable[K, V]; key: K; val: V)</a></li>
<li><a class="reference" href="#%5B%5D%3D%2CReactiveSeq%5BT%5D%2Cint%2CT" title="`[]=`[T](rs: ReactiveSeq[T]; idx: int; v: T)">`[]=`[T](rs: ReactiveSeq[T]; idx: int; v: T)</a></li>

</ul>
<ul class="simple nested-toc-section">clear
  <li><a class="reference" href="#clear%2CReactiveTable%5BK%2CV%5D" title="clear[K, V](rt: ReactiveTable[K, V])">clear[K, V](rt: ReactiveTable[K, V])</a></li>
<li><a class="reference" href="#clear%2CReactiveSeq%5BT%5D" title="clear[T](rs: ReactiveSeq[T])">clear[T](rs: ReactiveSeq[T])</a></li>

</ul>
<ul class="simple nested-toc-section">clearUndo
  <li><a class="reference" href="#clearUndo%2CReactiveCtx" title="clearUndo(ctx: ReactiveCtx)">clearUndo(ctx: ReactiveCtx)</a></li>

</ul>
<ul class="simple nested-toc-section">computed
  <li><a class="reference" href="#computed%2CReactiveCtx%2Cproc%29%2Cproc%28T%29" title="computed[T](ctx: ReactiveCtx; getter: proc (): T; setter: proc (v: T) = nil): Signal[
    T]">computed[T](ctx: ReactiveCtx; getter: proc (): T; setter: proc (v: T) = nil): Signal[
    T]</a></li>

</ul>
<ul class="simple nested-toc-section">delKey
  <li><a class="reference" href="#delKey%2CReactiveTable%5BK%2CV%5D%2CK" title="delKey[K, V](rt: ReactiveTable[K, V]; key: K)">delKey[K, V](rt: ReactiveTable[K, V]; key: K)</a></li>

</ul>
<ul class="simple nested-toc-section">disableAutosave
  <li><a class="reference" href="#disableAutosave%2CReactiveCtx" title="disableAutosave(ctx: ReactiveCtx)">disableAutosave(ctx: ReactiveCtx)</a></li>

</ul>
<ul class="simple nested-toc-section">dispose
  <li><a class="reference" href="#dispose%2CReactiveCtx" title="dispose(ctx: ReactiveCtx)">dispose(ctx: ReactiveCtx)</a></li>

</ul>
<ul class="simple nested-toc-section">dumpDeps
  <li><a class="reference" href="#dumpDeps%2CSignal" title="dumpDeps(s: Signal): seq[string]">dumpDeps(s: Signal): seq[string]</a></li>

</ul>
<ul class="simple nested-toc-section">effect
  <li><a class="reference" href="#effect%2CReactiveCtx%2Cproc%29" title="effect(ctx: ReactiveCtx; body: proc ())">effect(ctx: ReactiveCtx; body: proc ())</a></li>
<li><a class="reference" href="#effect%2CReactiveCtx%2Cproc%28AddCleanup%29" title="effect(ctx: ReactiveCtx; body: proc (onCleanup: AddCleanup))">effect(ctx: ReactiveCtx; body: proc (onCleanup: AddCleanup))</a></li>

</ul>
<ul class="simple nested-toc-section">effectOnce
  <li><a class="reference" href="#effectOnce%2CReactiveCtx%2Cproc%29" title="effectOnce(ctx: ReactiveCtx; body: proc ())">effectOnce(ctx: ReactiveCtx; body: proc ())</a></li>

</ul>
<ul class="simple nested-toc-section">enableAutosave
  <li><a class="reference" href="#enableAutosave%2CReactiveCtx%2CJsonNode" title="enableAutosave(ctx: ReactiveCtx; target: var JsonNode)">enableAutosave(ctx: ReactiveCtx; target: var JsonNode)</a></li>

</ul>
<ul class="simple nested-toc-section">flushQueued
  <li><a class="reference" href="#flushQueued%2CReactiveCtx" title="flushQueued(ctx: ReactiveCtx)">flushQueued(ctx: ReactiveCtx)</a></li>

</ul>
<ul class="simple nested-toc-section">insert
  <li><a class="reference" href="#insert%2CReactiveSeq%5BT%5D%2Cint%2CT" title="insert[T](rs: ReactiveSeq[T]; idx: int; x: T)">insert[T](rs: ReactiveSeq[T]; idx: int; x: T)</a></li>

</ul>
<ul class="simple nested-toc-section">isPrimitive
  <li><a class="reference" href="#isPrimitive%2CNimNode" title="isPrimitive(n: NimNode): bool">isPrimitive(n: NimNode): bool</a></li>

</ul>
<ul class="simple nested-toc-section">loadState
  <li><a class="reference" href="#loadState%2CReactiveCtx%2CJsonNode" title="loadState(ctx: ReactiveCtx; src: JsonNode)">loadState(ctx: ReactiveCtx; src: JsonNode)</a></li>

</ul>
<ul class="simple nested-toc-section">memo
  <li><a class="reference" href="#memo%2CReactiveCtx%2C" title="memo[T](ctx: ReactiveCtx; selector: () -&gt; T): () -&gt; T">memo[T](ctx: ReactiveCtx; selector: () -&gt; T): () -&gt; T</a></li>

</ul>
<ul class="simple nested-toc-section">newReactiveCtx
  <li><a class="reference" href="#newReactiveCtx" title="newReactiveCtx(): ReactiveCtx">newReactiveCtx(): ReactiveCtx</a></li>

</ul>
<ul class="simple nested-toc-section">pop
  <li><a class="reference" href="#pop%2CReactiveSeq%5BT%5D" title="pop[T](rs: ReactiveSeq[T]): T">pop[T](rs: ReactiveSeq[T]): T</a></li>

</ul>
<ul class="simple nested-toc-section">push
  <li><a class="reference" href="#push%2CReactiveSeq%5BT%5D%2CT" title="push[T](rs: ReactiveSeq[T]; x: T)">push[T](rs: ReactiveSeq[T]; x: T)</a></li>

</ul>
<ul class="simple nested-toc-section">put
  <li><a class="reference" href="#put%2CReactiveTable%5BK%2CV%5D%2CK%2CV" title="put[K, V](rt: ReactiveTable[K, V]; key: K; val: V)">put[K, V](rt: ReactiveTable[K, V]; key: K; val: V)</a></li>

</ul>
<ul class="simple nested-toc-section">redo
  <li><a class="reference" href="#redo%2CReactiveCtx%2Cint" title="redo(ctx: ReactiveCtx; steps = 1)">redo(ctx: ReactiveCtx; steps = 1)</a></li>

</ul>
<ul class="simple nested-toc-section">redoDepth
  <li><a class="reference" href="#redoDepth%2CReactiveCtx" title="redoDepth(ctx: ReactiveCtx): int">redoDepth(ctx: ReactiveCtx): int</a></li>

</ul>
<ul class="simple nested-toc-section">registerStore
  <li><a class="reference" href="#registerStore%2CReactiveCtx%2Cstring%2CSignal%5BT%5D" title="registerStore[T](ctx: ReactiveCtx; key: string; s: Signal[T])">registerStore[T](ctx: ReactiveCtx; key: string; s: Signal[T])</a></li>

</ul>
<ul class="simple nested-toc-section">removeIdx
  <li><a class="reference" href="#removeIdx%2CReactiveSeq%5BT%5D%2Cint" title="removeIdx[T](rs: ReactiveSeq[T]; idx: int)">removeIdx[T](rs: ReactiveSeq[T]; idx: int)</a></li>

</ul>
<ul class="simple nested-toc-section">saveState
  <li><a class="reference" href="#saveState%2CReactiveCtx%2CJsonNode" title="saveState(ctx: ReactiveCtx; dest: var JsonNode)">saveState(ctx: ReactiveCtx; dest: var JsonNode)</a></li>

</ul>
<ul class="simple nested-toc-section">set
  <li><a class="reference" href="#set%2CSignal%5BT%5D%2CT" title="set[T](s: Signal[T]; v: T)">set[T](s: Signal[T]; v: T)</a></li>

</ul>
<ul class="simple nested-toc-section">signal
  <li><a class="reference" href="#signal%2CReactiveCtx%2CT" title="signal[T](ctx: ReactiveCtx; v: T): Signal[T]">signal[T](ctx: ReactiveCtx; v: T): Signal[T]</a></li>

</ul>
<ul class="simple nested-toc-section">snapshot
  <li><a class="reference" href="#snapshot%2CReactiveCtx" title="snapshot(ctx: ReactiveCtx): int">snapshot(ctx: ReactiveCtx): int</a></li>

</ul>
<ul class="simple nested-toc-section">store
  <li><a class="reference" href="#store%2CReactiveCtx%2Cstring%2CT" title="store[T](ctx: ReactiveCtx; key: string; init: T): Signal[T]">store[T](ctx: ReactiveCtx; key: string; init: T): Signal[T]</a></li>

</ul>
<ul class="simple nested-toc-section">toPlain
  <li><a class="reference" href="#toPlain%2CReactiveTable%5BK%2CV%5D" title="toPlain[K, V](rt: ReactiveTable[K, V]): Table[K, V]">toPlain[K, V](rt: ReactiveTable[K, V]): Table[K, V]</a></li>
<li><a class="reference" href="#toPlain%2CReactiveSeq%5BT%5D" title="toPlain[T](rs: ReactiveSeq[T]): seq[T]">toPlain[T](rs: ReactiveSeq[T]): seq[T]</a></li>

</ul>
<ul class="simple nested-toc-section">toReactive
  <li><a class="reference" href="#toReactive%2CReactiveCtx%2CTable%5BK%2CV%5D" title="toReactive[K, V](ctx: ReactiveCtx; src: Table[K, V]): ReactiveTable[K, V]">toReactive[K, V](ctx: ReactiveCtx; src: Table[K, V]): ReactiveTable[K, V]</a></li>
<li><a class="reference" href="#toReactive%2CReactiveCtx%2Cseq%5BT%5D" title="toReactive[T](ctx: ReactiveCtx; src: seq[T]): ReactiveSeq[T]">toReactive[T](ctx: ReactiveCtx; src: seq[T]): ReactiveSeq[T]</a></li>

</ul>
<ul class="simple nested-toc-section">travel
  <li><a class="reference" href="#travel%2CReactiveCtx%2Cint" title="travel(ctx: ReactiveCtx; index: int)">travel(ctx: ReactiveCtx; index: int)</a></li>

</ul>
<ul class="simple nested-toc-section">undo
  <li><a class="reference" href="#undo%2CReactiveCtx%2Cint" title="undo(ctx: ReactiveCtx; steps = 1)">undo(ctx: ReactiveCtx; steps = 1)</a></li>

</ul>
<ul class="simple nested-toc-section">undoDepth
  <li><a class="reference" href="#undoDepth%2CReactiveCtx" title="undoDepth(ctx: ReactiveCtx): int">undoDepth(ctx: ReactiveCtx): int</a></li>

</ul>
<ul class="simple nested-toc-section">useFrameScheduler
  <li><a class="reference" href="#useFrameScheduler%2CReactiveCtx%2Cproc%28proc%29%29" title="useFrameScheduler(ctx: ReactiveCtx; enqueueNextFrm: proc (cb: proc ()))">useFrameScheduler(ctx: ReactiveCtx; enqueueNextFrm: proc (cb: proc ()))</a></li>

</ul>
<ul class="simple nested-toc-section">useQueuedScheduler
  <li><a class="reference" href="#useQueuedScheduler%2CReactiveCtx" title="useQueuedScheduler(ctx: ReactiveCtx)">useQueuedScheduler(ctx: ReactiveCtx)</a></li>

</ul>
<ul class="simple nested-toc-section">watch
  <li><a class="reference" href="#watch%2CReactiveCtx%2C%2Cproc%28T%2CT%29" title="watch[T](ctx: ReactiveCtx; selector: () -&gt; T; handler: proc (newVal, oldVal: T);
         immediate = false)">watch[T](ctx: ReactiveCtx; selector: () -&gt; T; handler: proc (newVal, oldVal: T);
         immediate = false)</a></li>

</ul>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#15" id="65">Iterators</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">items
  <li><a class="reference" href="#items.i%2CReactiveSeq%5BT%5D" title="items[T](rs: ReactiveSeq[T]): T">items[T](rs: ReactiveSeq[T]): T</a></li>

</ul>
<ul class="simple nested-toc-section">values
  <li><a class="reference" href="#values.i%2CReactiveTable%5BK%2CV%5D" title="values[K, V](rt: ReactiveTable[K, V]): V">values[K, V](rt: ReactiveTable[K, V]): V</a></li>

</ul>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#17" id="67">Macros</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">reactive
  <li><a class="reference" href="#reactive.m%2Ctypedesc" title="reactive(T: typedesc): untyped">reactive(T: typedesc): untyped</a></li>

</ul>

    </ul>
  </details>
</li>
<li>
  <details open>
    <summary><a class="reference reference-toplevel" href="#18" id="68">Templates</a></summary>
    <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">$
  <li><a class="reference" href="#%24.t%2CSignal" title="`$`(s: Signal): untyped">`$`(s: Signal): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">*=
  <li><a class="reference" href="#%2A%3D.t%2CSignal%5BT%5D%2CT" title="`*=`[T](s: Signal[T]; d: T)">`*=`[T](s: Signal[T]; d: T)</a></li>

</ul>
<ul class="simple nested-toc-section">+=
  <li><a class="reference" href="#%2B%3D.t%2CSignal%5BT%5D%2CT" title="`+=`[T](s: Signal[T]; d: T)">`+=`[T](s: Signal[T]; d: T)</a></li>

</ul>
<ul class="simple nested-toc-section">-=
  <li><a class="reference" href="#-%3D.t%2CSignal%5BT%5D%2CT" title="`-=`[T](s: Signal[T]; d: T)">`-=`[T](s: Signal[T]; d: T)</a></li>

</ul>
<ul class="simple nested-toc-section">[]
  <li><a class="reference" href="#%5B%5D.t%2CReactiveSeq%5BT%5D%2Cint" title="`[]`[T](rs: ReactiveSeq[T]; idx: int): untyped">`[]`[T](rs: ReactiveSeq[T]; idx: int): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">len
  <li><a class="reference" href="#len.t%2CReactiveSeq" title="len(rs: ReactiveSeq): untyped">len(rs: ReactiveSeq): untyped</a></li>
<li><a class="reference" href="#len.t%2CReactiveTable" title="len(rt: ReactiveTable): untyped">len(rt: ReactiveTable): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">peek
  <li><a class="reference" href="#peek.t%2CSignal%5BT%5D" title="peek[T](s: Signal[T]): untyped">peek[T](s: Signal[T]): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">peekLen
  <li><a class="reference" href="#peekLen.t%2CReactiveSeq" title="peekLen(rs: ReactiveSeq): untyped">peekLen(rs: ReactiveSeq): untyped</a></li>
<li><a class="reference" href="#peekLen.t%2CReactiveTable" title="peekLen(rt: ReactiveTable): untyped">peekLen(rt: ReactiveTable): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">peekRev
  <li><a class="reference" href="#peekRev.t%2CReactiveTable" title="peekRev(rt: ReactiveTable): untyped">peekRev(rt: ReactiveTable): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">rev
  <li><a class="reference" href="#rev.t%2CReactiveSeq" title="rev(rs: ReactiveSeq): untyped">rev(rs: ReactiveSeq): untyped</a></li>
<li><a class="reference" href="#rev.t%2CReactiveTable" title="rev(rt: ReactiveTable): untyped">rev(rt: ReactiveTable): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">transaction
  <li><a class="reference" href="#transaction.t%2CReactiveCtx%2Cuntyped" title="transaction(ctx: ReactiveCtx; body: untyped)">transaction(ctx: ReactiveCtx; body: untyped)</a></li>

</ul>
<ul class="simple nested-toc-section">val
  <li><a class="reference" href="#val.t%2CSignal" title="val(s: Signal): untyped">val(s: Signal): untyped</a></li>

</ul>
<ul class="simple nested-toc-section">watchNow
  <li><a class="reference" href="#watchNow.t%2CReactiveCtx%2C%2Cproc%28T%2CT%29" title="watchNow[T](ctx: ReactiveCtx; selector: () -&gt; T;
            handler: proc (newVal, oldVal: T))">watchNow[T](ctx: ReactiveCtx; selector: () -&gt; T;
            handler: proc (newVal, oldVal: T))</a></li>

</ul>

    </ul>
  </details>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc">
<h1><a class="toc-backref" id="signals-minus-durable-reactive-effects-for-nim" href="#signals-minus-durable-reactive-effects-for-nim">Signals - Durable Reactive Effects for Nim</a></h1><p>This module implements <em>signals</em> and a lightweight runtime that keeps values, collections, and whole object graphs in sync automatically. The key ideas and how they fit together are outlined below. Each concept links to the concrete API symbol that realises it.</p>
<p><strong><em>Signals</em></strong></p>
<ul class="simple"><li>A <a class="reference internal nimdoc" title="type Signal" href="#Signal">Signal</a> stores one value of type <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> and remembers every observer that reads it through <a class="reference internal nimdoc" title="template val(s: Signal): untyped" href="#val.t,Signal">val</a> (or wrapper access).</li>
<li>Writing with <a class="reference internal nimdoc" title="proc set[T](s: Signal[T]; v: T)" href="#set,Signal[T],T">set</a> records an undo entry, notifies observers via the active scheduler, and marks the context dirty for autosave.</li>
</ul>
<p><strong><em>Derived values</em></strong></p>
<ul class="simple"><li><a class="reference internal nimdoc" title="proc computed[T](ctx: ReactiveCtx; getter: proc (): T; setter: proc (v: T) = nil): Signal[
    T]" href="#computed,ReactiveCtx,proc),proc(T)">computed</a> builds a new signal from other signals and caches the result until any dependency changes.</li>
<li><a class="reference internal nimdoc" title="proc memo[T](ctx: ReactiveCtx; selector: () -&gt; T): () -&gt; T" href="#memo,ReactiveCtx,">memo</a> offers the same caching but exposes a plain callable instead of a signal.</li>
<li><a class="reference internal nimdoc" title="proc effect (2 overloads)" href="#effect-procs-all">effect</a> and its cleanup variant run side effects when dependencies change, while <a class="reference internal nimdoc" title="proc effectOnce(ctx: ReactiveCtx; body: proc ())" href="#effectOnce,ReactiveCtx,proc)">effectOnce</a> runs exactly one time.</li>
</ul>
<p><strong><em>Batching and atomic updates</em></strong></p>
<ul class="simple"><li><a class="reference internal nimdoc" title="template transaction(ctx: ReactiveCtx; body: untyped)" href="#transaction.t,ReactiveCtx,untyped">transaction</a> temporarily increments <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">batching</span></span></tt>. Every signal write inside the block queues notifications and coalesces history so observers and autosave fire only once after the outermost transaction ends.</li>
</ul>
<p><strong><em>Undo and redo</em></strong></p>
<ul class="simple"><li>Each effective change pushes a <a class="reference internal nimdoc" title="tuple HistoryEntry" href="#HistoryEntry">HistoryEntry</a> onto the undo stack.</li>
<li><a class="reference internal nimdoc" title="proc undo(ctx: ReactiveCtx; steps = 1)" href="#undo,ReactiveCtx,int">undo</a> pops entries, calls their undo callback, and moves them to the redo stack; <a class="reference internal nimdoc" title="proc redo(ctx: ReactiveCtx; steps = 1)" href="#redo,ReactiveCtx,int">redo</a> moves them back.</li>
<li><a class="reference internal nimdoc" title="proc snapshot(ctx: ReactiveCtx): int" href="#snapshot,ReactiveCtx">snapshot</a> captures the current depth and <a class="reference internal nimdoc" title="proc travel(ctx: ReactiveCtx; index: int)" href="#travel,ReactiveCtx,int">travel</a> jumps to any snapshot by replaying the needed undo or redo steps.</li>
<li><a class="reference internal nimdoc" title="proc undoDepth(ctx: ReactiveCtx): int" href="#undoDepth,ReactiveCtx">undoDepth</a> and <a class="reference internal nimdoc" title="proc redoDepth(ctx: ReactiveCtx): int" href="#redoDepth,ReactiveCtx">redoDepth</a> report the current stack sizes.</li>
</ul>
<p><strong><em>Persistence</em></strong></p>
<ul class="simple"><li>Any signal can be registered with <a class="reference internal nimdoc" title="proc store[T](ctx: ReactiveCtx; key: string; init: T): Signal[T]" href="#store,ReactiveCtx,string,T">store</a> or <a class="reference internal nimdoc" title="proc registerStore[T](ctx: ReactiveCtx; key: string; s: Signal[T])" href="#registerStore,ReactiveCtx,string,Signal[T]">registerStore</a>.</li>
<li><a class="reference internal nimdoc" title="proc saveState(ctx: ReactiveCtx; dest: var JsonNode)" href="#saveState,ReactiveCtx,JsonNode">saveState</a> serialises all store signals into a flat JSON object; <a class="reference internal nimdoc" title="proc loadState(ctx: ReactiveCtx; src: JsonNode)" href="#loadState,ReactiveCtx,JsonNode">loadState</a> restores them.</li>
<li><a class="reference internal nimdoc" title="proc enableAutosave(ctx: ReactiveCtx; target: var JsonNode)" href="#enableAutosave,ReactiveCtx,JsonNode">enableAutosave</a> / <a class="reference internal nimdoc" title="proc disableAutosave(ctx: ReactiveCtx)" href="#disableAutosave,ReactiveCtx">disableAutosave</a> write one snapshot per flush automatically.</li>
</ul>
<p><strong><em>Containers</em></strong></p>
<ul class="simple"><li><a class="reference internal nimdoc" title="type ReactiveSeq" href="#ReactiveSeq">ReactiveSeq</a> wraps a <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt>. Index access returns element signals; structural mutators update <a class="reference internal nimdoc" title="template len (2 overloads)" href="#len-templates-all">len</a> and <a class="reference internal nimdoc" title="template rev (2 overloads)" href="#rev-templates-all">rev</a>.</li>
<li><a class="reference internal nimdoc" title="type ReactiveTable" href="#ReactiveTable">ReactiveTable</a> wraps a <tt class="docutils literal"><span class="pre"><span class="Identifier">Table</span></span></tt>. Key access returns value signals and structural edits update <a class="reference internal nimdoc" title="template len (2 overloads)" href="#len-templates-all">len</a> and <a class="reference internal nimdoc" title="template rev (2 overloads)" href="#rev-templates-all">rev</a> for the table.</li>
</ul>
<p><strong><em>Object wrappers</em></strong></p>
<ul class="simple"><li>The <a class="reference internal nimdoc" title="macro reactive(T: typedesc): untyped" href="#reactive.m,typedesc">reactive</a> macro generates a parallel <tt class="docutils literal"><span class="pre"><span class="Identifier">XReactive</span></span></tt> type whose fields are signals or nested reactive wrappers.</li>
<li><a class="reference internal nimdoc" title="proc toReactive (2 overloads)" href="#toReactive-procs-all">toReactive</a> converts a plain object or collection into its wrapper; <a class="reference internal nimdoc" title="proc toPlain (2 overloads)" href="#toPlain-procs-all">toPlain</a> returns an immutable deep copy.</li>
</ul>
<p><strong><em>Schedulers</em></strong></p>
<ul class="simple"><li>The default immediate scheduler runs reactions at once.</li>
<li><a class="reference internal nimdoc" title="proc useQueuedScheduler(ctx: ReactiveCtx)" href="#useQueuedScheduler,ReactiveCtx">useQueuedScheduler</a> queues reactions until <a class="reference internal nimdoc" title="proc flushQueued(ctx: ReactiveCtx)" href="#flushQueued,ReactiveCtx">flushQueued</a> is called.</li>
<li><a class="reference internal nimdoc" title="proc useFrameScheduler(ctx: ReactiveCtx; enqueueNextFrm: proc (cb: proc ()))" href="#useFrameScheduler,ReactiveCtx,proc(proc))">useFrameScheduler</a> batches reactions per render frame.</li>
</ul>
<p><strong><em>Context lifecycle</em></strong></p>
<ul class="simple"><li>All reactive entities belong to a <a class="reference internal nimdoc" title="type ReactiveCtx" href="#ReactiveCtx">ReactiveCtx</a>.</li>
<li>Create one with <a class="reference internal nimdoc" title="proc newReactiveCtx(): ReactiveCtx" href="#newReactiveCtx">newReactiveCtx</a>, dispose it with <a class="reference internal nimdoc" title="proc dispose(ctx: ReactiveCtx)" href="#dispose,ReactiveCtx">dispose</a>.</li>
<li>After disposal signal writes still change the stored value but no reactions, history entries, or autosave snapshots are produced</li>
</ul>
</p>
    <div class="section" id="7">
  <h1><a class="toc-backref" href="#7">Types</a></h1>
  <dl class="item">
    <div id="AddCleanup">
  <dt><pre><a href="signals.html#AddCleanup"><span class="Identifier">AddCleanup</span></a> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">c</span><span class="Other">:</span> <a href="signals.html#Cleanup"><span class="Identifier">Cleanup</span></a><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>
Type alias for the <em>onCleanup</em> callback that can be passed to <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>.</p>
<p>A cleanup is a <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> that will be executed <strong>right before</strong> the enclosing effect runs again or when its <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveCtx</span></span></tt> is disposed. Use it to tear down timers, event handlers, or other external resources that the effect created.</p>
<p><strong><em>Workflow</em></strong></p>
<p><pre class="listing"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">effect</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">onCleanup</span><span class="Punctuation">:</span> <span class="Identifier">AddCleanup</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">timer</span> <span class="Operator">=</span> <span class="Identifier">setTimer</span><span class="Punctuation">(</span><span class="DecNumber">1000</span><span class="Punctuation">,</span> <span class="Identifier">step</span><span class="Punctuation">)</span>    <span class="Comment"># acquire resource</span>
  <span class="Identifier">onCleanup</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">clearTimer</span><span class="Punctuation">(</span><span class="Identifier">timer</span><span class="Punctuation">)</span>   <span class="Comment"># release it next run / dispose</span>
<span class="Punctuation">)</span></pre></p>
<ul class="simple"><li>The effect runs once, establishing its dependencies.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">onCleanup</span></span></tt> registers any number of callbacks.</li>
<li>Before the effect re-executes, each callback is invoked in the <strong>order they were added</strong>.</li>
</ul>
<p><strong><em>When to use</em></strong></p>
<ul class="simple"><li>Setting up and tearing down external listeners (DOM, sockets, timers).</li>
<li>Releasing memory or file handles that live only for the lifetime of the effect.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li><strong>Do not</strong> call <tt class="docutils literal"><span class="pre"><span class="Identifier">onCleanup</span></span></tt> conditionally inside loops; register once per resource or you may leak callbacks.</li>
<li>A cleanup runs even if the signal values did not actually change, as long as the effect re-evaluates; design idempotent cleanup code.</li>
<li>Calling <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> triggers cleanups exactly once; further writes to the same signals will no longer schedule cleanups.</li>
</ul>

    
  </dd>
</div>
<div id="Cleanup">
  <dt><pre><a href="signals.html#Cleanup"><span class="Identifier">Cleanup</span></a> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>
Zero-argument callback that releases a resource previously created by an <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>. A <tt class="docutils literal"><span class="pre"><span class="Identifier">Cleanup</span></span></tt> is registered through the <tt class="docutils literal"><span class="pre"><span class="Identifier">AddCleanup</span></span></tt> callback passed to <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt> (see that doc comment for usage details) and is executed right before the effect runs again or when the owning <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveCtx</span></span></tt> is disposed.</p>
<p>Typical tasks performed in a <tt class="docutils literal"><span class="pre"><span class="Identifier">Cleanup</span></span></tt>:</p>
<ul class="simple"><li>clearing timers</li>
<li>unbinding event listeners</li>
<li>closing files or sockets</li>
</ul>
<p>Keep the body idempotent and side-effect free beyond the intended teardown; it may be called even when signal values did not change if the effect re-evaluates for other reasons.</p>

    
  </dd>
</div>
<div id="HistoryEntry">
  <dt><pre><a href="signals.html#HistoryEntry"><span class="Identifier">HistoryEntry</span></a> <span class="Other">=</span> <span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">undo</span><span class="Other">,</span> <span class="Identifier">redo</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>
Internal record used by the undo/redo system.</p>
<p>A <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> stores two zero-argument procs:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt>  â€“ restores the previous state.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt>  â€“ reapplies the change that <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> reverted.</li>
</ul>
<p>The reactive engine pushes one <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> onto the contextâ€™s undo stack for every <em>effective</em> state change that occurs outside of an explicit call to <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span></span></tt>.</p>
<p><strong><em>How it fits in</em></strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> pops an entry, calls <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt>, and pushes the same entry onto the redo stack.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> pops from the redo stack, calls <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt>, and pushes the entry back onto the undo stack.</li>
</ul>
<p><strong><em>When to interact with it</em></strong></p>
<p>End-users do not create <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> values directly. They appear only if you are extending the library with new reactive container types and need to record structural or batched changes. In that case create an entry and push it just like the built-in seq and table wrappers do.</p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>The procs must <strong>not</strong> capture values by reference that can go out of scope before the entry is executed.</li>
<li>Do not call signal setters inside <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt> that would push <em>new</em> history entries; set the raw field values instead or wrap the call inside <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isUndoing</span></span></tt> / <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isRedoing</span></span></tt>.</li>
</ul>

    
  </dd>
</div>
<div id="ReactiveCtx">
  <dt><pre><a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span></pre></dt>
  <dd>
    
    <p>
A runtime container that owns and orchestrates every reactive entity in one isolated graph.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Each <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveCtx</span></span></tt> keeps its own signals, effects, scheduler, undo/redo history, and autosave target. Creating more than one context lets you run independent reactive sub-systems side by side.</p>
<p><strong><em>Key responsibilities</em></strong></p>
<ul class="simple"><li>Stores all signals created with <tt class="docutils literal"><span class="pre"><span class="Identifier">signal</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt> and wrappers built with <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">toReactive</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></span></tt>.</li>
<li>Queues and flushes reactions according to the active scheduler (immediate, queued, or frame).</li>
<li>Batches changes while inside <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Operator">...</span></span></tt>.</li>
<li>Records <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> objects so that <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt> can travel through time.</li>
<li>Handles autosave by calling <tt class="docutils literal"><span class="pre"><span class="Identifier">saveInto</span></span></tt> once per flush when dirty.</li>
<li>Shuts everything down and runs pending cleanups when <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> is called.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">ctx</span> <span class="Operator">=</span> <span class="Identifier">newReactiveCtx</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">hp</span>  <span class="Operator">=</span> <span class="Identifier">signal</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="DecNumber">100</span><span class="Punctuation">)</span>
<span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">echo</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">)</span>
<span class="Identifier">hp</span> <span class="Operator">-=</span> <span class="DecNumber">10</span>            <span class="Comment"># effect prints 90</span></pre></p>
<p>Most programs keep one long-lived context. Tests, modal dialogs, or background jobs often create short-lived contexts so they can dispose them cleanly.</p>
<p><strong><em>When to create multiple contexts</em></strong></p>
<ul class="simple"><li>You need separate undo/redo stacks.</li>
<li>Different parts of the app should flush on different schedulers.</li>
<li>Large data sets need to be unloaded and all reactive memory freed at once via <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span></span></tt>.</li>
</ul>
<p><strong><em>Pitfalls and rules</em></strong></p>
<ul class="simple"><li>Never move a signal between contexts; create it in the context that will own it.</li>
<li>After <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> reactions stop, but raw <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span></span></tt> values can still mutate silently; avoid further writes.</li>
<li>Make sure every <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span></span></tt> block leaves <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">batching</span></span></tt> back at 0 even on exceptions.</li>
<li>Public helpers (<tt class="docutils literal"><span class="pre"><span class="Identifier">signal</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>, ...) expect a valid, live context; passing a disposed one is a logic error.</li>
</ul>

    
  </dd>
</div>
<div id="ReactiveSeq">
  <dt><pre><a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span></pre></dt>
  <dd>
    
    <p>
A signal-aware wrapper around a Nim <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>. Every element is stored in its own <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>, and structural edits (push, insert, remove, clear) are tracked so effects can depend on the length or on the existence of elements.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> when you need a growable list whose <em>structure and element values</em> both drive reactive updates. Structural changes push history items, participate in transactions, and trigger autosave just like normal signal writes.</p>
<p><strong><em>Core behavior</em></strong></p>
<ul class="simple"><li>Index access <tt class="docutils literal"><span class="pre"><span class="Identifier">rs</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> returns the <strong>element signal</strong>; read or write it with <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">val</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> are signals that change when the length or structure changes.</li>
<li>Structural mutators: <tt class="docutils literal"><span class="pre"><span class="Identifier">push</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">pop</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">insert</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">removeIdx</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">clear</span></span></tt>.</li>
<li>Value writes on an element signal do <strong>not</strong> change <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> but do push their own undo record.</li>
<li>Inside a <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span></span></tt> multiple structural edits coalesce into one <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt>.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">rs</span> <span class="Operator">=</span> <span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">toReactive</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;b&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span>   <span class="Comment"># wrap an existing seq</span>

<span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;count:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">rs</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="StringLit">&quot;c&quot;</span>        <span class="Comment"># effect prints count:3</span>
<span class="Identifier">rs</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">set</span> <span class="StringLit">&quot;A&quot;</span>      <span class="Comment"># structural len unchanged</span>
<span class="Identifier">undo</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span>          <span class="Comment"># removes &quot;c&quot;</span></pre></p>
<p><strong><em>When to choose ReactiveSeq</em></strong></p>
<ul class="simple"><li>Lists in UI state (inventory items, chat messages, menu entries).</li>
<li>Any ordered collection where individual items update independently.</li>
<li>You need fine-grained undo/redo that distinguishes structural vs value edits.</li>
</ul>
<p><strong><em>Pitfalls and rules</em></strong></p>
<ul class="simple"><li>Keep references to element signals (<tt class="docutils literal"><span class="pre"><span class="Keyword">let</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">rs</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span></span></tt>) only while the element exists; deleting the index orphanes the signal.</li>
<li>Writing <tt class="docutils literal"><span class="pre"><span class="Identifier">rs</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">v</span></span></tt> when <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> is out of range is a logic error.</li>
<li>Large loops that write many elements individually should be wrapped in <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> to avoid hundreds of history entries.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> yields plain values, so no dependency is tracked; use explicit index reads if you need reactivity inside loops.</li>
</ul>

    
  </dd>
</div>
<div id="ReactiveTable">
  <dt><pre><a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">;</span> <span class="Identifier">V</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span></pre></dt>
  <dd>
    
    <p>
Reactive wrapper around a <tt class="docutils literal"><span class="pre"><span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span></span></tt>. Each key maps to its own <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span><span class="Punctuation">[</span><span class="Identifier">V</span><span class="Punctuation">]</span></span></tt>, and structural edits are tracked so effects can depend on the entry count or on changes to the key set.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> when you need a dictionary whose keys may appear or disappear at runtime and whose values must update dependent code automatically. Both structural operations and per value writes integrate with undo, redo, transactions, and autosave.</p>
<p><strong><em>Core behavior</em></strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">rt</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">]</span></span></tt> returns the value signal for that key, creating a new signal with <tt class="docutils literal"><span class="pre"><span class="Identifier">default</span><span class="Punctuation">(</span><span class="Identifier">V</span><span class="Punctuation">)</span></span></tt> if the key is missing.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> are signals that change when the size or the structure changes.</li>
<li>Structural mutators: <tt class="docutils literal"><span class="pre"><span class="Identifier">put</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">delKey</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">clear</span></span></tt>.</li>
<li>Writing through a value signal (<tt class="docutils literal"><span class="pre"><span class="Identifier">rt</span><span class="Punctuation">[</span><span class="StringLit">&quot;hp&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">set</span> <span class="DecNumber">10</span></span></tt>) leaves <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> unchanged but records its own history entry.</li>
<li>Inside <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> multiple structural edits collapse into one undo record.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">stats</span> <span class="Operator">=</span> <span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">toReactive</span><span class="Punctuation">(</span><span class="Identifier">initTable</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;entries:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">stats</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">stats</span><span class="Operator">.</span><span class="Identifier">put</span><span class="Punctuation">(</span><span class="StringLit">&quot;hp&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span>     <span class="Comment"># effect prints entries:1</span>
<span class="Identifier">stats</span><span class="Punctuation">[</span><span class="StringLit">&quot;hp&quot;</span><span class="Punctuation">]</span> <span class="Operator">+=</span> <span class="DecNumber">5</span>        <span class="Comment"># structural length unchanged</span>
<span class="Identifier">undo</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span>               <span class="Comment"># removes key &quot;hp&quot;</span></pre></p>
<p><strong><em>When to choose ReactiveTable</em></strong></p>
<ul class="simple"><li>Keyed collections in UI or game state, like entity maps or settings.</li>
<li>You need both value level and structural level undo and redo.</li>
<li>Autosave should persist a whole dictionary without manual loops.</li>
</ul>
<p><strong><em>Pitfalls and rules</em></strong></p>
<ul class="simple"><li>Keep references to value signals only while the key exists; deleting the key leaves the old signal orphaned.</li>
<li>Accessing <tt class="docutils literal"><span class="pre"><span class="Identifier">rt</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">]</span></span></tt> for a missing key creates it; use <tt class="docutils literal"><span class="pre"><span class="Identifier">hasKey</span></span></tt> on a plain table if you only want to test for existence.</li>
<li>Large batches of <tt class="docutils literal"><span class="pre"><span class="Identifier">put</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">delKey</span></span></tt> should be wrapped in <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> to avoid many history entries.</li>
<li>Remember to read <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> inside an effect if that effect should rerun on structural changes.</li>
</ul>

    
  </dd>
</div>
<div id="Signal">
  <dt><pre><a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span></pre></dt>
  <dd>
    
    <p>
Reactive value container that stores one <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> and notifies its subscribers when the value changes.</p>
<p><strong><em>Purpose</em></strong></p>
<p>A <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span></span></tt> is the basic building block of the library. All primitive fields wrapped by <tt class="docutils literal"><span class="pre"><span class="Identifier">reactive</span><span class="Punctuation">(</span><span class="Identifier">MyType</span><span class="Punctuation">)</span></span></tt> become signals. Effects and computed signals read them to establish dependencies, and any call to <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> triggers the update chain.</p>
<p><strong><em>Core behavior</em></strong></p>
<ul class="simple"><li>Read with <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">val</span></span></tt> or the <tt class="docutils literal"><span class="pre"><span class="Identifier">val</span><span class="Punctuation">(</span><span class="Identifier">signal</span><span class="Punctuation">)</span></span></tt> template.</li>
<li>Write with <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">+=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">-=</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Operator">*=</span></span></tt>.</li>
<li>Equality helpers let you compare a signal to a plain value in assertions.</li>
<li>If the new value equals the current one no history entry is recorded and no reactions fire.</li>
<li>Writes inside <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span></span></tt> bypass history push but still notify dependants.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">hp</span> <span class="Operator">=</span> <span class="Identifier">signal</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="DecNumber">100</span><span class="Punctuation">)</span>
<span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;HP:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">)</span>
<span class="Identifier">hp</span> <span class="Operator">-=</span> <span class="DecNumber">10</span>            <span class="Comment"># effect prints HP: 90</span></pre></p>
<p><strong><em>When to declare a Signal yourself</em></strong></p>
<ul class="simple"><li>Stand-alone values not part of a reactive object wrapper.</li>
<li>Global settings that require independent undo history.</li>
<li>Quick experiments or tests where a full wrapper type is overkill.</li>
</ul>
<p><strong><em>Pitfalls and rules</em></strong></p>
<ul class="simple"><li>Never create a signal without passing the owning <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveCtx</span></span></tt>.</li>
<li>Avoid writing the same value repeatedly; it adds no benefit but still triggers change detection.</li>
<li>Signals are reference types; copying a <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> variable copies the reference, not the value.</li>
<li>After <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> writing a signal mutates the stored value but no reactions will run.</li>
</ul>

    
  </dd>
</div>

  </dl>
</div>
<div class="section" id="12">
  <h1><a class="toc-backref" href="#12">Procs</a></h1>
  <dl class="item">
    <div id="==-procs-all">
  <div id="==,ReactiveTable[K,V],Table[K,V]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CReactiveTable%5BK%2CV%5D%2CTable%5BK%2CV%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,Table[K,V],ReactiveTable[K,V]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CTable%5BK%2CV%5D%2CReactiveTable%5BK%2CV%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,ReactiveSeq[T],seq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CReactiveSeq%5BT%5D%2Cseq%5BT%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    Convert ReactiveSeq to plain seq once and compare element-wise.
    
  </dd>
</div>
<div id="==,seq[Signal[T]],seq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2Cseq%5BSignal%5BT%5D%5D%2Cseq%5BT%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,seq[T],ReactiveSeq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2Cseq%5BT%5D%2CReactiveSeq%5BT%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,seq[T],seq[Signal[T]]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2Cseq%5BT%5D%2Cseq%5BSignal%5BT%5D%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,seq[T],Signal[seq[T]]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2Cseq%5BT%5D%2CSignal%5Bseq%5BT%5D%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,Signal[seq[T]],seq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CSignal%5Bseq%5BT%5D%5D%2Cseq%5BT%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,Signal[T],T">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CSignal%5BT%5D%2CT"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="==,T,Signal[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#%3D%3D%2CT%2CSignal%5BT%5D"><span class="Identifier">`==`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">a</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">;</span> <span class="Identifier">b</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="[]-procs-all">
  <div id="[],ReactiveTable[K,V],K">
  <dt><pre><span class="Keyword">proc</span> <a href="#%5B%5D%2CReactiveTable%5BK%2CV%5D%2CK"><span class="Identifier">`[]`</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">K</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">V</span><span class="Other">]</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="[]=-procs-all">
  <div id="[]=,ReactiveTable[K,V],K,V">
  <dt><pre><span class="Keyword">proc</span> <a href="#%5B%5D%3D%2CReactiveTable%5BK%2CV%5D%2CK%2CV"><span class="Identifier">`[]=`</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">K</span><span class="Other">;</span> <span class="Identifier">val</span><span class="Other">:</span> <span class="Identifier">V</span><span class="Other">)</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>
<div id="[]=,ReactiveSeq[T],int,T">
  <dt><pre><span class="Keyword">proc</span> <a href="#%5B%5D%3D%2CReactiveSeq%5BT%5D%2Cint%2CT"><span class="Identifier">`[]=`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="clear-procs-all">
  <div id="clear,ReactiveTable[K,V]">
  <dt><pre><span class="Keyword">proc</span> <a href="#clear%2CReactiveTable%5BK%2CV%5D"><span class="Identifier">clear</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Removes all key-value pairs in one step.</p>
<p><strong><em>Effect on reactivity</em></strong></p>
<ul class="simple"><li>Pushes a single structural history entry (or joins the active transaction).</li>
<li>Resets <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> to 0 and bumps <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt>.</li>
<li>Triggers any effects that depend on length or structure.</li>
</ul>

    
  </dd>
</div>
<div id="clear,ReactiveSeq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#clear%2CReactiveSeq%5BT%5D"><span class="Identifier">clear</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span></pre></dt>
  <dd>
    
    Removes all elements from the reactive sequence.<ul class="simple"><li>Structural edit: sets length to 0 and increments <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt>.</li>
<li>Pushes one history entry (or merges into an active transaction).</li>
<li>Effects that depend on length or structure rerun after the flush.</li>
</ul>
<p>Raises no error when the sequence is already empty.</p>

    
  </dd>
</div>

</div>
<div id="clearUndo-procs-all">
  <div id="clearUndo,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#clearUndo%2CReactiveCtx"><span class="Identifier">clearUndo</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p><strong><em>Purpose</em></strong></p>
<p>Erases both the undo and redo stacks of the given context without altering current state.</p>
<p><strong><em>When to call</em></strong></p>
<ul class="simple"><li>Before loading a fresh document or scene where old history should not apply.</li>
<li>In tests that want to assert depth from a clean slate.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Users can no longer undo the edits made earlier in the session.</li>
<li>Does not stop reactions; only history is cleared.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="computed-procs-all">
  <div id="computed,ReactiveCtx,proc),proc(T)">
  <dt><pre><span class="Keyword">proc</span> <a href="#computed%2CReactiveCtx%2Cproc%29%2Cproc%28T%29"><span class="Identifier">computed</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">getter</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">;</span> <span class="Identifier">setter</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span> <span class="Other">=</span> <span class="Keyword">nil</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span>
    <span class="Identifier">T</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>Creates a derived signal whose value is calculated by <tt class="docutils literal"><span class="pre"><span class="Identifier">getter</span></span></tt>. The result is cached and recomputed only when any signal read inside <tt class="docutils literal"><span class="pre"><span class="Identifier">getter</span></span></tt> has changed. If <tt class="docutils literal"><span class="pre"><span class="Identifier">setter</span></span></tt> is supplied the computed signal becomes writable; calling <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">pct</span><span class="Operator">.</span><span class="Identifier">set</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> forwards the write to <tt class="docutils literal"><span class="pre"><span class="Identifier">setter</span></span></tt>.</p>
<p><strong><em>How it fits in</em></strong></p>
<ul class="simple"><li>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span></span></tt> for values that can be expressed entirely in terms of other signals.</li>
<li>Effects depending on the computed signal see a single dependency instead of all the sources used inside <tt class="docutils literal"><span class="pre"><span class="Identifier">getter</span></span></tt>.</li>
<li>Writable computed signals let you expose a convenient virtual field (for example percent health) that writes back to one or more base signals.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">pct</span> <span class="Operator">=</span> <span class="Identifier">computed</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span>
  <span class="Identifier">getter</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Operator">.</span><span class="Identifier">float</span> <span class="Operator">/</span> <span class="Identifier">maxHp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Operator">.</span><span class="Identifier">float</span><span class="Punctuation">,</span>
  <span class="Identifier">setter</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">set</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">p</span> <span class="Operator">*</span> <span class="Identifier">maxHp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Operator">.</span><span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">pct</span><span class="Operator">.</span><span class="Identifier">val</span>   <span class="Comment"># read</span>
<span class="Identifier">pct</span><span class="Operator">.</span><span class="Identifier">set</span> <span class="FloatNumber">0.8</span>    <span class="Comment"># write through setter</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">getter</span></span></tt> runs immediately when <tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span></span></tt> is created; avoid heavy work or side effects inside it.</li>
<li>Do not call <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> on the computed signal from inside its own <tt class="docutils literal"><span class="pre"><span class="Identifier">getter</span></span></tt>; that would cause infinite recursion.</li>
<li>If <tt class="docutils literal"><span class="pre"><span class="Identifier">setter</span></span></tt> writes the same value back into the sources the engine detects no change and pushes no history entry.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="delKey-procs-all">
  <div id="delKey,ReactiveTable[K,V],K">
  <dt><pre><span class="Keyword">proc</span> <a href="#delKey%2CReactiveTable%5BK%2CV%5D%2CK"><span class="Identifier">delKey</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">K</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Removes <tt class="docutils literal"><span class="pre"><span class="Identifier">key</span></span></tt> from the reactive table if it exists.</p>
<p><strong><em>Reactive effects</em></strong></p>
<ul class="simple"><li>Structural operation; bumps <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> and updates <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt>.</li>
<li>Pushes a history entry (or merges into an open transaction).</li>
<li>Effects that depend on length or on <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> rerun.</li>
</ul>
<p>Keys that are not present are ignored and no history entry is added.</p>

    
  </dd>
</div>

</div>
<div id="disableAutosave-procs-all">
  <div id="disableAutosave,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#disableAutosave%2CReactiveCtx"><span class="Identifier">disableAutosave</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Turns off automatic persistence for the context. No further snapshots are written to the JSON node that was previously passed to <tt class="docutils literal"><span class="pre"><span class="Identifier">enableAutosave</span></span></tt>.</p>
<p><strong><em>Effect</em></strong></p>
<ul class="simple"><li>Clears the autosave flag and the stored node reference.</li>
<li>Does not perform a final save; call <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> first if you need the latest state persisted.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>After disabling, edits to store signals will not reach the old JSON node unless autosave is enabled again or <tt class="docutils literal"><span class="pre"><span class="Identifier">saveState</span></span></tt> is called manually.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="dispose-procs-all">
  <div id="dispose,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#dispose%2CReactiveCtx"><span class="Identifier">dispose</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">KeyError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
                                 <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Stops all reactive activity owned by <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt> and frees its resources.</p>
<p><strong><em>What happens</em></strong></p>
<ul class="simple"><li>If autosave is active a final snapshot is written before shutdown.</li>
<li>Pending reaction queues and history stacks are cleared.</li>
<li>Scheduler is replaced with a no-op and <tt class="docutils literal"><span class="pre"><span class="Identifier">currentObserver</span></span></tt> is set to nil, so no further reactions run.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isDisposed</span></span></tt> becomes true; helper procs treat the context as dead.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">ctx</span> <span class="Operator">=</span> <span class="Identifier">newReactiveCtx</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Operator">...</span>
<span class="Identifier">dispose</span> <span class="Identifier">ctx</span>      <span class="Comment"># when the data set or UI panel is closed</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Writing to a signal after disposal mutates its raw value but triggers no reactions or autosave.</li>
<li>A disposed context cannot be revived. Create a new context instead.</li>
<li>Transactions open at the moment of disposal are silently cancelled.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="dumpDeps-procs-all">
  <div id="dumpDeps,Signal">
  <dt><pre><span class="Keyword">proc</span> <a href="#dumpDeps%2CSignal"><span class="Identifier">dumpDeps</span></a><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span></pre></dt>
  <dd>
    
    Return a seq of hex strings, one per subscriber callback. Helpful for quick &quot;who depends on this signal?&quot; debugging.
    
  </dd>
</div>

</div>
<div id="effect-procs-all">
  <div id="effect,ReactiveCtx,proc)">
  <dt><pre><span class="Keyword">proc</span> <a href="#effect%2CReactiveCtx%2Cproc%29"><span class="Identifier">effect</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Registers <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> as a reactive side effect. The procedure runs once immediately, collects every signal it reads, and is scheduled to run again whenever any of those signals changes.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Effects are the bridge from reactive data to the outside world. Use them for printing, updating the UI, sending network messages, or any work whose result is not itself a signal.</p>
<p><strong><em>How it works</em></strong></p>
<ul class="simple"><li>During the first call <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">currentObserver</span></span></tt> is set to the callback so every signal read registers the dependency automatically.</li>
<li>Later writes to any of those signals schedule the effect.</li>
<li>If the active scheduler is queued or frame based, the run happens on the next <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> or frame tick.</li>
<li>Dependencies are re-collected on every run; if <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> stops reading a signal it will be unsubscribed.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;HP:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">,</span> <span class="StringLit">&quot;/&quot;</span><span class="Punctuation">,</span> <span class="Identifier">maxHp</span><span class="Operator">.</span><span class="Identifier">val</span>
<span class="Punctuation">)</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Do not mutate signals inside the same effect that reads them unless you are certain it will not cause infinite loops.</li>
<li>An effect runs even if the computed result is identical; add manual checks if you need extra deduplication.</li>
<li>Heavy work should be batched or throttled to avoid frame drops under rapid updates.</li>
</ul>

    
  </dd>
</div>
<div id="effect,ReactiveCtx,proc(AddCleanup)">
  <dt><pre><span class="Keyword">proc</span> <a href="#effect%2CReactiveCtx%2Cproc%28AddCleanup%29"><span class="Identifier">effect</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">onCleanup</span><span class="Other">:</span> <a href="signals.html#AddCleanup"><span class="Identifier">AddCleanup</span></a><span class="Other">)</span><span class="Other">)</span> {.
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Registers a reactive side effect that can schedule cleanup callbacks. <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> receives an <tt class="docutils literal"><span class="pre"><span class="Identifier">onCleanup</span></span></tt> function; every <tt class="docutils literal"><span class="pre"><span class="Identifier">Cleanup</span></span></tt> registered with it runs right before the effect re executes or when the context is disposed.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Same as the simple <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>, plus deterministic setup and teardown of resources such as timers, event listeners, or file handles.</p>
<p><strong><em>Usage pattern</em></strong></p>
<p><pre class="listing"><span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">onCleanup</span><span class="Punctuation">:</span> <span class="Identifier">AddCleanup</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">id</span> <span class="Operator">=</span> <span class="Identifier">setTimer</span><span class="Punctuation">(</span><span class="DecNumber">1000</span><span class="Punctuation">,</span> <span class="Identifier">tick</span><span class="Punctuation">)</span>
  <span class="Identifier">onCleanup</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">clearTimer</span><span class="Punctuation">(</span><span class="Identifier">id</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Punctuation">)</span></pre></p>
<ul class="simple"><li>First run: acquire resources, register cleanups, establish dependencies.</li>
<li>On every re run: all cleanups fire, then the body executes again.</li>
<li>On <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt>: any remaining cleanups run once.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Register each resource exactly once; adding inside loops can leak callbacks.</li>
<li>Cleanups run even when signal values did not change if the effect still re evaluates. Keep them lightweight and idempotent.</li>
<li>Avoid calling <tt class="docutils literal"><span class="pre"><span class="Identifier">onCleanup</span></span></tt> conditionally based on signal values that may differ between runs; otherwise the number of callbacks can grow unbounded.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="effectOnce-procs-all">
  <div id="effectOnce,ReactiveCtx,proc)">
  <dt><pre><span class="Keyword">proc</span> <a href="#effectOnce%2CReactiveCtx%2Cproc%29"><span class="Identifier">effectOnce</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Executes <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> immediately and never schedules it again, even if the procedure reads signals that later change. Dependency tracking is disabled during the call.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">effectOnce</span></span></tt> for one time side effects such as logging, initialising third party libraries, or writing a first snapshot after startup.</p>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Identifier">effectOnce</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Initial HP:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span>
<span class="Punctuation">)</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Because no dependencies are collected, later updates do not trigger the procedure. Choose a normal <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt> if you need ongoing reactivity.</li>
<li>Cleanups cannot be registered; allocate resources only if they live for the full lifetime of the context.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="enableAutosave-procs-all">
  <div id="enableAutosave,ReactiveCtx,JsonNode">
  <dt><pre><span class="Keyword">proc</span> <a href="#enableAutosave%2CReactiveCtx%2CJsonNode"><span class="Identifier">enableAutosave</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">target</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">JsonNode</span><span class="Other">)</span> {.
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">KeyError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Activates automatic persistence for all store-registered signals in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>. The current values are written into <tt class="docutils literal"><span class="pre"><span class="Identifier">target</span></span></tt> immediately and once per flush whenever any store signal changes.</p>
<p><strong><em>How it works</em></strong></p>
<ul class="simple"><li>If <tt class="docutils literal"><span class="pre"><span class="Identifier">target</span></span></tt> is <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> a new empty JSON object is created.</li>
<li>Every call to <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> (or an automatic flush by the scheduler) serialises the latest store snapshot into the same JSON node. Existing keys are overwritten, other keys in <tt class="docutils literal"><span class="pre"><span class="Identifier">target</span></span></tt> remain.</li>
<li>On <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> a final snapshot is written.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">doc</span><span class="Punctuation">:</span> <span class="Identifier">JsonNode</span>
<span class="Identifier">enableAutosave</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">doc</span><span class="Punctuation">)</span>      <span class="Comment"># initial snapshot</span>
<span class="Identifier">gold</span> <span class="Operator">+=</span> <span class="DecNumber">10</span>                    <span class="Comment"># mutate a store signal</span>
<span class="Identifier">flushQueued</span> <span class="Identifier">ctx</span>               <span class="Comment"># doc updated</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Keep <tt class="docutils literal"><span class="pre"><span class="Identifier">target</span></span></tt> alive as long as autosave is enabled; if you reassign the variable the library keeps the old reference.</li>
<li>Call <tt class="docutils literal"><span class="pre"><span class="Identifier">disableAutosave</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> before switching to a new node to avoid unintentionally writing into both.</li>
<li>Immediate scheduler writes right away; queued or frame schedulers require an explicit flush or a frame tick.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="flushQueued-procs-all">
  <div id="flushQueued,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#flushQueued%2CReactiveCtx"><span class="Identifier">flushQueued</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">,</span> <span class="Identifier">KeyError</span><span class="Other">]</span><span class="Other">,</span>
                                     <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Runs all reactions currently waiting in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">queue</span></span></tt> and then, if autosave is enabled and the context is marked dirty, writes one snapshot to the autosave JSON node.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span></span></tt> when working with the queued or frame schedulers if you need to force updates immediately, or in automated tests where you want deterministic timing without depending on the scheduler loop.</p>
<p><strong><em>What it does</em></strong></p>
<ul class="simple"><li>Copies the current queue, clears it, and executes each reaction once.</li>
<li>Clears <tt class="docutils literal"><span class="pre"><span class="Identifier">queueHashes</span></span></tt> so the same reaction can be queued again later.</li>
<li>If autosave is active and any write happened since the last snapshot, serialises the store signals into the target JSON node.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Identifier">useQueuedScheduler</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span>
<span class="Identifier">value</span><span class="Operator">.</span><span class="Identifier">set</span> <span class="DecNumber">42</span>       <span class="Comment"># effect is queued</span>
<span class="Identifier">flushQueued</span> <span class="Identifier">ctx</span>    <span class="Comment"># run it right now</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Do not call inside a <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span></span></tt>; the batch is not finished until the outer transaction flushes.</li>
<li>Immediate scheduler users never need this call because reactions run at once.</li>
<li>Flushing very often defeats the coalescing benefit of queued schedulers.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="insert-procs-all">
  <div id="insert,ReactiveSeq[T],int,T">
  <dt><pre><span class="Keyword">proc</span> <a href="#insert%2CReactiveSeq%5BT%5D%2Cint%2CT"><span class="Identifier">insert</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">;</span> <span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    Inserts <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> at position <tt class="docutils literal"><span class="pre"><span class="Identifier">idx</span></span></tt>, shifting later elements to the right. Counts as a structural edit: pushes one history entry (or joins the current transaction), updates <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt>, and reruns effects that depend on length or structure. <tt class="docutils literal"><span class="pre"><span class="Identifier">idx</span></span></tt> must be in the range 0 .. rs.len.
    
  </dd>
</div>

</div>
<div id="isPrimitive-procs-all">
  <div id="isPrimitive,NimNode">
  <dt><pre><span class="Keyword">proc</span> <a href="#isPrimitive%2CNimNode"><span class="Identifier">isPrimitive</span></a><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Returns <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> if <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> represents one of the built-in scalar types supported by the <tt class="docutils literal"><span class="pre"><span class="Identifier">reactive</span></span></tt> macro (int, float, bool, string, etc.). Used internally when generating wrapper fields to decide whether a source field should become a simple <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span></span></tt> or a nested reactive wrapper. Application code rarely needs this helper.
    
  </dd>
</div>

</div>
<div id="loadState-procs-all">
  <div id="loadState,ReactiveCtx,JsonNode">
  <dt><pre><span class="Keyword">proc</span> <a href="#loadState%2CReactiveCtx%2CJsonNode"><span class="Identifier">loadState</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">JsonNode</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">,</span> <span class="Identifier">KeyError</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Replaces the values of all store-registered signals in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt> with the contents of <tt class="docutils literal"><span class="pre"><span class="Identifier">src</span></span></tt>. Keys that are missing in <tt class="docutils literal"><span class="pre"><span class="Identifier">src</span></span></tt> leave their signals unchanged. Signals not registered with <tt class="docutils literal"><span class="pre"><span class="Identifier">store</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">registerStore</span></span></tt> are unaffected.</p>
<p><strong><em>Typical workflow</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">snapshot</span><span class="Punctuation">:</span> <span class="Identifier">JsonNode</span>
<span class="Identifier">saveState</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">snapshot</span><span class="Punctuation">)</span>   <span class="Comment"># later...</span>
<span class="Identifier">loadState</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">snapshot</span><span class="Punctuation">)</span>   <span class="Comment"># restore previous snapshot</span></pre></p>
<p><strong><em>Effects on history and reactions</em></strong></p>
<ul class="simple"><li>Each <tt class="docutils literal"><span class="pre"><span class="Identifier">setter</span></span></tt> call triggered by <tt class="docutils literal"><span class="pre"><span class="Identifier">loadState</span></span></tt> pushes its own undo record unless the context is inside <tt class="docutils literal"><span class="pre"><span class="Identifier">isUndoing</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">isRedoing</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">isDisposed</span></span></tt>.</li>
<li>Reactions fire normally after the load; wrap the call in <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> if you want one coalesced update.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">src</span></span></tt> must not be <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt>; pass an empty object to clear all stored keys.</li>
<li>Data types are not validated beyond basic conversion; loading a float into an int signal raises a value error.</li>
<li>The redo stack is cleared after the first new write; if you load a snapshot and then set a signal manually the forward history is lost.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="memo-procs-all">
  <div id="memo,ReactiveCtx,">
  <dt><pre><span class="Keyword">proc</span> <a href="#memo%2CReactiveCtx%2C"><span class="Identifier">memo</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">selector</span><span class="Other">:</span> <span class="Other">(</span><span class="Other">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Other">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">T</span></pre></dt>
  <dd>
    
    <p>Creates a memoised selector. The returned closure reads its cached value without tracking dependencies, while an internal effect keeps that cache up to date by running <tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> again only when any of the signals it reads change.</p>
<p><strong><em>Purpose</em></strong></p>
<p>Use <tt class="docutils literal"><span class="pre"><span class="Identifier">memo</span></span></tt> to avoid expensive recalculation or to expose a selector that can be read many times without causing additional reactivity churn.</p>
<p><strong><em>How it works</em></strong></p>
<ul class="simple"><li>On creation <tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> runs once, collects its dependencies, and stores the result.</li>
<li>An internal effect reruns <tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> when any dependency changes and updates the cache.</li>
<li>The returned closure just returns the current cache, adding itself as a dependency of callers.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">sum</span> <span class="Operator">=</span> <span class="Identifier">memo</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">val</span> <span class="Operator">+</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">sum</span><span class="Punctuation">(</span><span class="Punctuation">)</span>   <span class="Comment"># fast cached read</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Do not call <tt class="docutils literal"><span class="pre"><span class="Identifier">memo</span></span></tt> inside another effect if the selector performs heavy work; create it once at module or context setup time.</li>
<li>Values are compared with <tt class="docutils literal"><span class="pre"><span class="Operator">!=</span></span></tt>; if <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> has complex equality rules make sure that still detects real changes.</li>
<li>The memo itself never pushes undo history; only the underlying signal writes do.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="newReactiveCtx-procs-all">
  <div id="newReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#newReactiveCtx"><span class="Identifier">newReactiveCtx</span></a><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Constructs and returns a fresh <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveCtx</span></span></tt> with the default immediate scheduler and empty history, queues, and store list.</p>
<p><strong><em>When to call</em></strong></p>
<ul class="simple"><li>At application startup to create the primary reactive graph.</li>
<li>Inside tests or short-lived components to obtain an isolated context that can be disposed without affecting the rest of the program.</li>
</ul>
<p>The new context is clean: <tt class="docutils literal"><span class="pre"><span class="Identifier">undoDepth</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">redoDepth</span></span></tt>, and <tt class="docutils literal"><span class="pre"><span class="Identifier">queue</span><span class="Operator">.</span><span class="Identifier">len</span></span></tt> are all zero, <tt class="docutils literal"><span class="pre"><span class="Identifier">isDisposed</span></span></tt> is false, and autosave is disabled.</p>

    
  </dd>
</div>

</div>
<div id="pop-procs-all">
  <div id="pop,ReactiveSeq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#pop%2CReactiveSeq%5BT%5D"><span class="Identifier">pop</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span></pre></dt>
  <dd>
    
    Removes and returns the last element of the reactive sequence. Counts as a structural edit: pushes one undo entry (or joins the current transaction), updates <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt>, and reruns effects that depend on length or structure. Raises <tt class="docutils literal"><span class="pre"><span class="Identifier">IndexDefect</span></span></tt> if the sequence is empty.
    
  </dd>
</div>

</div>
<div id="push-procs-all">
  <div id="push,ReactiveSeq[T],T">
  <dt><pre><span class="Keyword">proc</span> <a href="#push%2CReactiveSeq%5BT%5D%2CT"><span class="Identifier">push</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Appends <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> to the end of the reactive sequence.</p>
<p><strong><em>Reactive effects</em></strong></p>
<ul class="simple"><li>Structural edit: length grows by 1 and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> increments.</li>
<li>Pushes one history entry or merges into an open transaction.</li>
<li>Effects that depend on length or structure rerun.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="put-procs-all">
  <div id="put,ReactiveTable[K,V],K,V">
  <dt><pre><span class="Keyword">proc</span> <a href="#put%2CReactiveTable%5BK%2CV%5D%2CK%2CV"><span class="Identifier">put</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">K</span><span class="Other">;</span> <span class="Identifier">val</span><span class="Other">:</span> <span class="Identifier">V</span><span class="Other">)</span></pre></dt>
  <dd>
    
    Adds or replaces <tt class="docutils literal"><span class="pre"><span class="Identifier">key</span></span></tt> in the reactive table with <tt class="docutils literal"><span class="pre"><span class="Identifier">val</span></span></tt>. If the key already exists the element signal is updated; otherwise a new element signal is created and a structural history entry is pushed. Effects watching <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rt</span><span class="Punctuation">)</span></span></tt> rerun only when the key did not exist before.
    
  </dd>
</div>

</div>
<div id="redo-procs-all">
  <div id="redo,ReactiveCtx,int">
  <dt><pre><span class="Keyword">proc</span> <a href="#redo%2CReactiveCtx%2Cint"><span class="Identifier">redo</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">steps</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Travels forward in the undo history <tt class="docutils literal"><span class="pre"><span class="Identifier">steps</span></span></tt> times (default 1). Pops entries from the redo stack, executes their <tt class="docutils literal"><span class="pre"><span class="Identifier">redo</span></span></tt> callbacks, pushes them back onto the undo stack, and schedules reactions. Has no effect when the redo stack is empty.
    
  </dd>
</div>

</div>
<div id="redoDepth-procs-all">
  <div id="redoDepth,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#redoDepth%2CReactiveCtx"><span class="Identifier">redoDepth</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">int</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Returns the current size of the redo stack for <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>. Useful in debugging UIs to enable or disable a 'Redo' button.
    
  </dd>
</div>

</div>
<div id="registerStore-procs-all">
  <div id="registerStore,ReactiveCtx,string,Signal[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#registerStore%2CReactiveCtx%2Cstring%2CSignal%5BT%5D"><span class="Identifier">registerStore</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">;</span> <span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span></pre></dt>
  <dd>
    
    Adds <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span></span></tt> to the context's store list under <tt class="docutils literal"><span class="pre"><span class="Identifier">key</span></span></tt> so that future calls to <tt class="docutils literal"><span class="pre"><span class="Identifier">saveState</span></span></tt> or active autosave snapshots include its value. Can be called at any time, even after autosave was already enabled.
    
  </dd>
</div>

</div>
<div id="removeIdx-procs-all">
  <div id="removeIdx,ReactiveSeq[T],int">
  <dt><pre><span class="Keyword">proc</span> <a href="#removeIdx%2CReactiveSeq%5BT%5D%2Cint"><span class="Identifier">removeIdx</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Removes the element at <tt class="docutils literal"><span class="pre"><span class="Identifier">idx</span></span></tt> from a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt>.</p>
<p><strong><em>Effects</em></strong></p>
<ul class="simple"><li>Structural edit: <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> update.</li>
<li>Pushes one history entry (or merges into an open transaction).</li>
<li>Triggers effects that depend on length or structure.</li>
</ul>
<p>Raises <tt class="docutils literal"><span class="pre"><span class="Identifier">IndexDefect</span></span></tt> if <tt class="docutils literal"><span class="pre"><span class="Identifier">idx</span></span></tt> is out of range.</p>

    
  </dd>
</div>

</div>
<div id="saveState-procs-all">
  <div id="saveState,ReactiveCtx,JsonNode">
  <dt><pre><span class="Keyword">proc</span> <a href="#saveState%2CReactiveCtx%2CJsonNode"><span class="Identifier">saveState</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">dest</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">JsonNode</span><span class="Other">)</span> {.
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">KeyError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Writes a snapshot of all store-registered signals in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt> into <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span></span></tt>.</p>
<p><strong><em>Rules</em></strong></p>
<ul class="simple"><li>Allocates a new JSON object when <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span></span></tt> is <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt>.</li>
<li>Overwrites existing keys that match store entries; leaves others untouched.</li>
<li>Does not clear history or fire reactions.</li>
</ul>
<p>Use before closing a document or for manual export; for continuous persistence prefer <tt class="docutils literal"><span class="pre"><span class="Identifier">enableAutosave</span></span></tt>.</p>

    
  </dd>
</div>

</div>
<div id="set-procs-all">
  <div id="set,Signal[T],T">
  <dt><pre><span class="Keyword">proc</span> <a href="#set%2CSignal%5BT%5D%2CT"><span class="Identifier">set</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Writes a new value into a <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span></span></tt>.</p>
<p><strong><em>Purpose</em></strong></p>
<p>This is the fundamental mutation primitive; every shortcut such as <tt class="docutils literal"><span class="pre"><span class="Operator">+=</span></span></tt> or elementâ€signal writes eventually calls <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt>.</p>
<ul class="simple"><li><strong>History</strong> Pushes one <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> that stores both the old and the new value, unless <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isUndoing</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isRedoing</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">isDisposed</span></span></tt> is true.</li>
<li><strong>Effects and computed signals</strong> All subscribers collected through dependency tracking are notified. The actual reaction runs immediately on the immediate scheduler or is queued for <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> / the next frame on other schedulers.</li>
<li><strong>Transactions</strong> Inside <tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> several calls to <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> are coalesced: the history entry is created when the outermost transaction finishes and reactions fire once per flush, not per call.</li>
<li><strong>Autosave</strong> Marks the context dirty so the next flush (manual or scheduled) writes a snapshot when autosave is enabled.</li>
<li><strong>Writable computed signals</strong> When the target signal has a custom setter (<tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">,</span> <span class="Identifier">setter</span><span class="Operator">=...</span><span class="Punctuation">)</span></span></tt>) the call is forwarded there instead of storing into the signalâ€™s own field, thus supporting virtual two-way bindings.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Writing the <em>same</em> value is ignored; no history entry, no reactions.</li>
<li>Do not call <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> inside the getter of the same computed signal; that creates infinite recursion.</li>
<li>After <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> the value still mutates but no reactions, history entries, or autosave snapshots will be produced.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="signal-procs-all">
  <div id="signal,ReactiveCtx,T">
  <dt><pre><span class="Keyword">proc</span> <a href="#signal%2CReactiveCtx%2CT"><span class="Identifier">signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">v</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>Allocates a new <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> owned by <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt> and initialised to <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span></span></tt>.</p>
<p><strong><em>Why you need it</em></strong></p>
<ul class="simple"><li>Stand-alone reactive values that are not part of a <tt class="docutils literal"><span class="pre"><span class="Identifier">reactive</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></span></tt> object wrapper.</li>
<li>Global settings or counters that several wrappers or effects share.</li>
<li>Quick prototypes or tests where defining a wrapper type is overkill.</li>
<li>Can be read (<tt class="docutils literal"><span class="pre"><span class="Identifier">sig</span><span class="Operator">.</span><span class="Identifier">val</span></span></tt>) inside <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">memo</span></span></tt> to establish dependencies that rerun those constructs when the signal changes.</li>
<li>Can be registered for persistence with <tt class="docutils literal"><span class="pre"><span class="Identifier">store</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">registerStore</span></span></tt>; autosave and <tt class="docutils literal"><span class="pre"><span class="Identifier">saveState</span></span></tt> will then serialise its value.</li>
<li>All writes made through <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> integrate with undo/redo, transactions, autosave, and the active scheduler as described for <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt>.</li>
</ul>
<p><strong><em>Typical workflow</em></strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">ctx</span> <span class="Operator">=</span> <span class="Identifier">newReactiveCtx</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">score</span> <span class="Operator">=</span> <span class="Identifier">signal</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">)</span>
<span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;score:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">score</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">)</span>
<span class="Identifier">score</span> <span class="Operator">+=</span> <span class="DecNumber">10</span>          <span class="Comment"># effect prints score: 10</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>A <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span></span></tt> is a reference object; copying the variable copies only the reference, not the value.</li>
<li>Signals must belong to exactly one context; never share the same signal instance across contexts.</li>
<li>After <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> creating new signals with that context or writing existing ones is a logic error that yields no reactive behaviour.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="snapshot-procs-all">
  <div id="snapshot,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#snapshot%2CReactiveCtx"><span class="Identifier">snapshot</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">int</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Creates a checkpoint of the current undo position and returns its index. Use the returned int later with <tt class="docutils literal"><span class="pre"><span class="Identifier">travel</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">index</span><span class="Punctuation">)</span></span></tt> to jump back or forward to this exact moment in history.  Snapshot indices grow monotonically and are valid until the undo and redo stacks are cleared or purged by <tt class="docutils literal"><span class="pre"><span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt>.
    
  </dd>
</div>

</div>
<div id="store-procs-all">
  <div id="store,ReactiveCtx,string,T">
  <dt><pre><span class="Keyword">proc</span> <a href="#store%2CReactiveCtx%2Cstring%2CT"><span class="Identifier">store</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">;</span> <span class="Identifier">init</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>Creates a new signal initialised to <tt class="docutils literal"><span class="pre"><span class="Identifier">init</span></span></tt>, registers it under <tt class="docutils literal"><span class="pre"><span class="Identifier">key</span></span></tt> for persistence, and returns the signal.  Future calls to <tt class="docutils literal"><span class="pre"><span class="Identifier">saveState</span></span></tt> or active autosave snapshots will serialize the signalâ€™s value using the same key in the JSON object.</p>
<p>Typical use:</p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">gold</span> <span class="Operator">=</span> <span class="Identifier">store</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="StringLit">&quot;gold&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">100</span><span class="Punctuation">)</span>
<span class="Identifier">enableAutosave</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">saveNode</span><span class="Punctuation">)</span>
<span class="Identifier">gold</span> <span class="Operator">+=</span> <span class="DecNumber">50</span>          <span class="Comment"># next flush writes {&quot;gold&quot;:150}</span></pre></p>

    
  </dd>
</div>

</div>
<div id="toPlain-procs-all">
  <div id="toPlain,ReactiveTable[K,V]">
  <dt><pre><span class="Keyword">proc</span> <a href="#toPlain%2CReactiveTable%5BK%2CV%5D"><span class="Identifier">toPlain</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span></pre></dt>
  <dd>
    
    Returns a plain <tt class="docutils literal"><span class="pre"><span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span></span></tt> that contains the current values of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt>.  The result is a deep copy; mutating it does not affect the reactive table or its signals.
    
  </dd>
</div>
<div id="toPlain,ReactiveSeq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#toPlain%2CReactiveSeq%5BT%5D"><span class="Identifier">toPlain</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
  <dd>
    
    Converts a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> into a plain <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> by copying the current element values. No dependencies are recorded and later changes to the reactive sequence do not affect the returned copy. Use this when you need an immutable snapshot for logging, JSON serialisation, or deep equality tests.
    
  </dd>
</div>

</div>
<div id="toReactive-procs-all">
  <div id="toReactive,ReactiveCtx,Table[K,V]">
  <dt><pre><span class="Keyword">proc</span> <a href="#toReactive%2CReactiveCtx%2CTable%5BK%2CV%5D"><span class="Identifier">toReactive</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>Wraps an existing <tt class="docutils literal"><span class="pre"><span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span></span></tt> in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>, producing a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> whose keys keep the same order and whose values are turned into individual signals. The original table is read once; subsequent edits must go through the <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> API to stay reactive.</p>
<p>Structural and value edits made after wrapping participate in transactions, undo and redo, autosave, and the scheduler just like any table created from scratch.</p>

    
  </dd>
</div>
<div id="toReactive,ReactiveCtx,seq[T]">
  <dt><pre><span class="Keyword">proc</span> <a href="#toReactive%2CReactiveCtx%2Cseq%5BT%5D"><span class="Identifier">toReactive</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">src</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span></pre></dt>
  <dd>
    
    <p>Wraps an existing <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> in <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>, producing a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> where every element becomes its own signal. The original sequence is copied once; later changes must be applied through the <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> mutators or by writing the element signals directly.</p>
<p>The resulting wrapper integrates with effects, transactions, undo and redo, autosave, and the active scheduler in the same way as a sequence built via repeated <tt class="docutils literal"><span class="pre"><span class="Identifier">push</span></span></tt> calls.</p>

    
  </dd>
</div>

</div>
<div id="travel-procs-all">
  <div id="travel,ReactiveCtx,int">
  <dt><pre><span class="Keyword">proc</span> <a href="#travel%2CReactiveCtx%2Cint"><span class="Identifier">travel</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Jumps to the snapshot at <tt class="docutils literal"><span class="pre"><span class="Identifier">index</span></span></tt>, the value previously returned by <tt class="docutils literal"><span class="pre"><span class="Identifier">snapshot</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt>. If <tt class="docutils literal"><span class="pre"><span class="Identifier">index</span></span></tt> is lower than the current undo depth the call performs the required number of undo steps. If it is higher the call performs redo steps. Out-of-range indices are ignored. Reactions fire after the move and autosave updates on the next flush.
    
  </dd>
</div>

</div>
<div id="undo-procs-all">
  <div id="undo,ReactiveCtx,int">
  <dt><pre><span class="Keyword">proc</span> <a href="#undo%2CReactiveCtx%2Cint"><span class="Identifier">undo</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">steps</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Reverses the last <tt class="docutils literal"><span class="pre"><span class="Identifier">steps</span></span></tt> history entries (default 1). For each step the most recent <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> is popped from the undo stack, its <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> callback runs, and the entry is pushed onto the redo stack. Reactions run after the batch and autosave marks the context dirty. Calling <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> when the stack is empty does nothing.
    
  </dd>
</div>

</div>
<div id="undoDepth-procs-all">
  <div id="undoDepth,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#undoDepth%2CReactiveCtx"><span class="Identifier">undoDepth</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">int</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    Returns the number of <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> objects currently stored in the undo stack of <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>. A quick way to decide whether an Undo button should be enabled in the UI.
    
  </dd>
</div>

</div>
<div id="useFrameScheduler-procs-all">
  <div id="useFrameScheduler,ReactiveCtx,proc(proc))">
  <dt><pre><span class="Keyword">proc</span> <a href="#useFrameScheduler%2CReactiveCtx%2Cproc%28proc%29%29"><span class="Identifier">useFrameScheduler</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">enqueueNextFrm</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">cb</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Other">)</span><span class="Other">)</span><span class="Other">)</span> {.
    <span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Installs a frame based reaction scheduler.</p>
<p><strong><em>Purpose</em></strong></p>
<p>In games and UI toolkits work is often grouped by frames. With the frame scheduler all reactions that occur within the same frame are batched and flushed once at the start of the next frame tick.</p>
<p><strong><em>How to wire it</em></strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">tasks</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Identifier">useFrameScheduler</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">cb</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">tasks</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">cb</span><span class="Punctuation">)</span>

<span class="Comment"># later in the render loop</span>
<span class="Keyword">for</span> <span class="Identifier">t</span> <span class="Keyword">in</span> <span class="Identifier">tasks</span><span class="Punctuation">:</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">tasks</span><span class="Operator">.</span><span class="Identifier">setLen</span> <span class="DecNumber">0</span></pre></p>
<p>The supplied <tt class="docutils literal"><span class="pre"><span class="Identifier">enqueueNextFrm</span></span></tt> must place <tt class="docutils literal"><span class="pre"><span class="Identifier">cb</span></span></tt> into a queue that the caller empties at the start of the next frame. The library calls <tt class="docutils literal"><span class="pre"><span class="Identifier">enqueueNextFrm</span></span></tt> exactly once per frame no matter how many reactions were queued.</p>
<p><strong><em>Effects on the engine</em></strong></p>
<ul class="simple"><li>Multiple signal writes per frame cause only one flush and one autosave, reducing redundant work.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> blocks still coalesce as usual; the flush happens on the next frame tick.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Forgetting to run the queued callback each frame will stall the reactive graph.</li>
<li>Calling <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> manually is still possible but defeats the batching benefit.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="useQueuedScheduler-procs-all">
  <div id="useQueuedScheduler,ReactiveCtx">
  <dt><pre><span class="Keyword">proc</span> <a href="#useQueuedScheduler%2CReactiveCtx"><span class="Identifier">useQueuedScheduler</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">)</span> {.<span><span class="Other pragmadots">...</span></span><span class="pragmawrap"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">forbids</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span>.}</pre></dt>
  <dd>
    
    <p>Switches to a simple queued scheduler.</p>
<p><strong><em>Behavior</em></strong></p>
<ul class="simple"><li>Every reaction triggered by a signal write is enqueued immediately.</li>
<li>Nothing runs until <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> is called.</li>
<li>Multiple queued reactions are executed in the order they were added, duplicates are filtered by hash.</li>
</ul>
<p><strong><em>When to use</em></strong></p>
<ul class="simple"><li>Unit tests that want deterministic timing without a frame loop.</li>
<li>Command-line tools that need to flush after processing a batch of input lines.</li>
<li>Situations where you need to guarantee that expensive work is delayed until an explicit sync point.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Forgetting to call <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> causes reactions and autosave to accumulate indefinitely.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="watch-procs-all">
  <div id="watch,ReactiveCtx,,proc(T,T)">
  <dt><pre><span class="Keyword">proc</span> <a href="#watch%2CReactiveCtx%2C%2Cproc%28T%2CT%29"><span class="Identifier">watch</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">selector</span><span class="Other">:</span> <span class="Other">(</span><span class="Other">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">T</span><span class="Other">;</span>
              <span class="Identifier">handler</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">newVal</span><span class="Other">,</span> <span class="Identifier">oldVal</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">;</span> <span class="Identifier">immediate</span> <span class="Other">=</span> <span class="Identifier">false</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Observes the output of <tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> and calls <tt class="docutils literal"><span class="pre"><span class="Identifier">handler</span></span></tt> whenever that output changes.</p>
<p><strong><em>Workflow</em></strong></p>
<ol class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> runs inside an internal effect, collecting dependencies and storing its result.</li>
<li>When any dependency changes the effect reruns; if the new result differs from the stored one <tt class="docutils literal"><span class="pre"><span class="Identifier">handler</span><span class="Punctuation">(</span><span class="Identifier">new</span><span class="Punctuation">,</span> <span class="Identifier">old</span><span class="Punctuation">)</span></span></tt> is invoked.</li>
<li>The stored result is updated to the new value.</li>
</ol>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">immediate</span></span></tt> controls whether the handler fires on the first evaluation.</p>
<p><strong><em>Use cases</em></strong></p>
<ul class="simple"><li>React when a numeric value crosses a threshold without caring about every intermediate change.</li>
<li>Run validation logic only when a composite selector result differs.</li>
<li>Trigger animations where only the final state of a batch matters.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Identifier">watch</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span>
  <span class="Identifier">selector</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span> <span class="Keyword">div</span> <span class="DecNumber">10</span><span class="Punctuation">,</span>
  <span class="Identifier">handler</span>  <span class="Operator">=</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">new</span><span class="Punctuation">,</span> <span class="Identifier">old</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;tens digit changed from&quot;</span><span class="Punctuation">,</span> <span class="Identifier">old</span><span class="Punctuation">,</span> <span class="StringLit">&quot;to&quot;</span><span class="Punctuation">,</span> <span class="Identifier">new</span><span class="Punctuation">,</span>
  <span class="Identifier">immediate</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Selector results are compared with <tt class="docutils literal"><span class="pre"><span class="Operator">!=</span></span></tt>. For complex types ensure that this equality test reflects real changes.</li>
<li>If the selector performs heavy work consider wrapping it in <tt class="docutils literal"><span class="pre"><span class="Identifier">memo</span></span></tt> first.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">handler</span></span></tt> runs inside the same flush that detected the change; avoid long running code that blocks other reactions.</li>
</ul>

    
  </dd>
</div>

</div>

  </dl>
</div>
<div class="section" id="15">
  <h1><a class="toc-backref" href="#15">Iterators</a></h1>
  <dl class="item">
    <div id="items-iterators-all">
  <div id="items.i,ReactiveSeq[T]">
  <dt><pre><span class="Keyword">iterator</span> <a href="#items.i%2CReactiveSeq%5BT%5D"><span class="Identifier">items</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">T</span></pre></dt>
  <dd>
    
    <p>Yields each element of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> as a plain value, from index 0 to <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span></span></tt>. Reading through this iterator does <strong>not</strong> establish reactive dependencies, because it reads the cached <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">val</span></span></tt> of each element without registering the iterator as an observer.</p>
<p>Use it to build snapshots or aggregate results without causing future updates to rerun the loop. If you need an effect to rerun when elements change, iterate with explicit <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">discard</span> <span class="Identifier">rs</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">val</span></span></tt> so each element signal is tracked.</p>

    
  </dd>
</div>

</div>
<div id="values-iterators-all">
  <div id="values.i,ReactiveTable[K,V]">
  <dt><pre><span class="Keyword">iterator</span> <a href="#values.i%2CReactiveTable%5BK%2CV%5D"><span class="Identifier">values</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">[</span><span class="Identifier">K</span><span class="Other">,</span> <span class="Identifier">V</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">V</span></pre></dt>
  <dd>
    
    <p>Yields the plain value of every entry in a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt>, in key order as produced by the containerâ€™s iterator. Like <tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt> on <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> this iterator does <strong>not</strong> establish dependencies; it simply reads <tt class="docutils literal"><span class="pre"><span class="Identifier">signal</span><span class="Operator">.</span><span class="Identifier">val</span></span></tt> for each stored value and returns the result.</p>
<p>Ideal for one-off summarisation or JSON export. If you need live reactivity over the values, iterate keys and read <tt class="docutils literal"><span class="pre"><span class="Identifier">rt</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">val</span></span></tt> explicitly so each value signal is tracked.</p>

    
  </dd>
</div>

</div>

  </dl>
</div>
<div class="section" id="17">
  <h1><a class="toc-backref" href="#17">Macros</a></h1>
  <dl class="item">
    <div id="reactive-macros-all">
  <div id="reactive.m,typedesc">
  <dt><pre><span class="Keyword">macro</span> <a href="#reactive.m%2Ctypedesc"><span class="Identifier">reactive</span></a><span class="Other">(</span><span class="Identifier">T</span><span class="Other">:</span> <span class="Identifier">typedesc</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    <p>Turns a value object type into a reactive wrapper type.</p>
<p><strong><em>What it generates</em></strong></p>
<p>For a source object <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span></span></tt> the macro produces</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">FooReactive</span></span></tt>        â€“ a ref object whose fields mirror <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span></span></tt> but each field is signal backed (primitive) or a nested wrapper (seq, table, or object).</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">toReactive</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Identifier">src</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span> <span class="Punctuation">:</span> <span class="Identifier">FooReactive</span></span></tt> â€“ copies <tt class="docutils literal"><span class="pre"><span class="Identifier">src</span></span></tt> into the wrapper, creating signals owned by <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">toPlain</span><span class="Punctuation">(</span><span class="Identifier">w</span><span class="Punctuation">:</span> <span class="Identifier">FooReactive</span><span class="Punctuation">)</span> <span class="Punctuation">:</span> <span class="Identifier">Foo</span></span></tt> â€“ returns a deep plain copy, breaking all reactive links.</li>
</ul>
<p><strong><em>Supported field kinds</em></strong></p>
<ul class="simple"><li>Primitive scalars (int, float, bool, string, char...) become <tt class="docutils literal"><span class="pre"><span class="Identifier">Signal</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> becomes <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>.</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">TableRef</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">OrderedTable</span></span></tt> becomes <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span></span></tt>.</li>
<li>Another object type becomes its own <tt class="docutils literal"><span class="pre"><span class="Identifier">XReactive</span></span></tt> wrapper recursively (you must call <tt class="docutils literal"><span class="pre"><span class="Identifier">reactive</span><span class="Punctuation">(</span><span class="Identifier">X</span><span class="Punctuation">)</span></span></tt> beforehand).</li>
<li>A field already ending in <tt class="docutils literal"><span class="pre"><span class="Identifier">Reactive</span></span></tt> is copied unchanged.</li>
</ul>
<p><strong><em>Typical usage</em></strong></p>
<p><pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Player</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  <span class="Identifier">hp</span><span class="Punctuation">:</span>   <span class="Identifier">int</span>
  <span class="Identifier">pos</span><span class="Punctuation">:</span>  <span class="Identifier">Vec2</span>

<span class="Identifier">reactive</span><span class="Punctuation">(</span><span class="Identifier">Player</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">toReactive</span><span class="Punctuation">(</span><span class="Identifier">Player</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Eve&quot;</span><span class="Punctuation">,</span> <span class="Identifier">hp</span><span class="Punctuation">:</span> <span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">pos</span><span class="Punctuation">:</span> <span class="Identifier">Vec2</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span><span class="DecNumber">0</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">hp</span> <span class="Operator">-=</span> <span class="DecNumber">10</span>                 <span class="Comment"># reactive write</span>
<span class="Identifier">echo</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">pos</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">val</span>           <span class="Comment"># reactive read</span></pre></p>
<p><strong><em>When to use</em></strong></p>
<ul class="simple"><li>Any structured data that needs fine grained reactivity without manual signal bookkeeping.</li>
<li>UI view models, game entities, or config records that benefit from undo/redo and autosave out of the box.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Only value objects are supported; the source type cannot have custom inheritance beyond <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt>.</li>
<li>Recursive types require defining the inner wrapper first.</li>
<li>Private fields become public in the wrapper; place sensitive data in a separate object if needed.</li>
</ul>

    
  </dd>
</div>

</div>

  </dl>
</div>
<div class="section" id="18">
  <h1><a class="toc-backref" href="#18">Templates</a></h1>
  <dl class="item">
    <div id="$-templates-all">
  <div id="$.t,Signal">
  <dt><pre><span class="Keyword">template</span> <a href="#%24.t%2CSignal"><span class="Identifier">`$`</span></a><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="*=-templates-all">
  <div id="*=.t,Signal[T],T">
  <dt><pre><span class="Keyword">template</span> <a href="#%2A%3D.t%2CSignal%5BT%5D%2CT"><span class="Identifier">`*=`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="+=-templates-all">
  <div id="+=.t,Signal[T],T">
  <dt><pre><span class="Keyword">template</span> <a href="#%2B%3D.t%2CSignal%5BT%5D%2CT"><span class="Identifier">`+=`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="-=-templates-all">
  <div id="-=.t,Signal[T],T">
  <dt><pre><span class="Keyword">template</span> <a href="#-%3D.t%2CSignal%5BT%5D%2CT"><span class="Identifier">`-=`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">d</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="[]-templates-all">
  <div id="[].t,ReactiveSeq[T],int">
  <dt><pre><span class="Keyword">template</span> <a href="#%5B%5D.t%2CReactiveSeq%5BT%5D%2Cint"><span class="Identifier">`[]`</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">int</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    
    
  </dd>
</div>

</div>
<div id="len-templates-all">
  <div id="len.t,ReactiveSeq">
  <dt><pre><span class="Keyword">template</span> <a href="#len.t%2CReactiveSeq"><span class="Identifier">len</span></a><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the current element count of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> <strong>and</strong> registers the caller as a subscriber. Any structural change (push, insert, remove, clear) updates the length signal and reruns effects that read it. Use this inside effects or computed signals when later mutations should trigger reactive updates.
    
  </dd>
</div>
<div id="len.t,ReactiveTable">
  <dt><pre><span class="Keyword">template</span> <a href="#len.t%2CReactiveTable"><span class="Identifier">len</span></a><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the number of key-value pairs stored in a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> and tracks the caller as a subscriber. Any structural change (put, delKey, clear) updates the length signal and reruns dependent effects or computed values. Ideal for counters and list-rendering logic that must stay in sync with the tableâ€™s size.
    
  </dd>
</div>

</div>
<div id="peek-templates-all">
  <div id="peek.t,Signal[T]">
  <dt><pre><span class="Keyword">template</span> <a href="#peek.t%2CSignal%5BT%5D"><span class="Identifier">peek</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    <p>Reads a signalâ€™s current value without registering a dependency. Useful inside effects when you need the data but do not want the effect to rerun on future changes.</p>
<p><pre class="listing"><span class="Identifier">effect</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=&gt;</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;debug:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">peek</span><span class="Punctuation">(</span><span class="Identifier">hp</span><span class="Punctuation">)</span>   <span class="Comment"># prints once, never reruns</span>
<span class="Punctuation">)</span></pre></p>

    
  </dd>
</div>

</div>
<div id="peekLen-templates-all">
  <div id="peekLen.t,ReactiveSeq">
  <dt><pre><span class="Keyword">template</span> <a href="#peekLen.t%2CReactiveSeq"><span class="Identifier">peekLen</span></a><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the length of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> without tracking the caller as a subscriber. Handy for quick size checks in places where you do not want to establish reactivity.
    
  </dd>
</div>
<div id="peekLen.t,ReactiveTable">
  <dt><pre><span class="Keyword">template</span> <a href="#peekLen.t%2CReactiveTable"><span class="Identifier">peekLen</span></a><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the entry count of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> without tracking a dependency. Use when you need the value once and do not want the caller to rerun on structural changes.
    
  </dd>
</div>

</div>
<div id="peekRev-templates-all">
  <div id="peekRev.t,ReactiveTable">
  <dt><pre><span class="Keyword">template</span> <a href="#peekRev.t%2CReactiveTable"><span class="Identifier">peekRev</span></a><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the revision counter of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> without tracking a dependency. Suitable for diagnostic logs or conditional code paths that should not trigger on future table mutations.
    
  </dd>
</div>

</div>
<div id="rev-templates-all">
  <div id="rev.t,ReactiveSeq">
  <dt><pre><span class="Keyword">template</span> <a href="#rev.t%2CReactiveSeq"><span class="Identifier">rev</span></a><span class="Other">(</span><span class="Identifier">rs</span><span class="Other">:</span> <a href="signals.html#ReactiveSeq"><span class="Identifier">ReactiveSeq</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the structural revision counter of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveSeq</span></span></tt> and tracks the caller as a subscriber. The counter increments every time the sequence structure changes (push, insert, remove, clear) regardless of whether the overall length changed. Useful when you need to rerun an effect on any structural edit, even those that keep the length constant, such as swapping two elements.
    
  </dd>
</div>
<div id="rev.t,ReactiveTable">
  <dt><pre><span class="Keyword">template</span> <a href="#rev.t%2CReactiveTable"><span class="Identifier">rev</span></a><span class="Other">(</span><span class="Identifier">rt</span><span class="Other">:</span> <a href="signals.html#ReactiveTable"><span class="Identifier">ReactiveTable</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    Returns the structural revision counter of a <tt class="docutils literal"><span class="pre"><span class="Identifier">ReactiveTable</span></span></tt> and tracks the caller as a subscriber. The counter increments on every key set, key removal, or <tt class="docutils literal"><span class="pre"><span class="Identifier">clear</span></span></tt>, allowing an effect to react to any structural mutation even when the entry count stays the same.
    
  </dd>
</div>

</div>
<div id="transaction-templates-all">
  <div id="transaction.t,ReactiveCtx,untyped">
  <dt><pre><span class="Keyword">template</span> <a href="#transaction.t%2CReactiveCtx%2Cuntyped"><span class="Identifier">transaction</span></a><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Runs <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> while incrementing <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">batching</span></span></tt>. Each nested call further increments the counter. Reactions, history entries, and autosave writes are suppressed until the counter returns to zero at the end of the outermost transaction.</p>
<p><strong><em>What is coalesced</em></strong></p>
<ul class="simple"><li><strong>Signal writes</strong> still update their stored value immediately but notifications go into <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">queue</span></span></tt> instead of running right away.</li>
<li><strong>ReactiveSeq / ReactiveTable structural edits</strong> save an <em>old</em> copy on the first mutation and postpone emitting their <tt class="docutils literal"><span class="pre"><span class="Identifier">HistoryEntry</span></span></tt> until the commit phase. Multiple edits of the same container collapse into one entry.</li>
<li><strong>Undo/redo depth</strong> therefore grows by at most one entry per distinct signal and one per structurally mutated container, no matter how many writes happened inside the block.</li>
</ul>
<p><strong><em>Commit phase</em></strong></p>
<p>When the outermost transaction exits (<tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">batching</span></span></tt> becomes zero) the template:</p>
<ol class="simple"><li>hands a flush request to the current scheduler</li>
<li>the scheduler later calls <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> which<ul class="simple"><li>executes queued reactions once each</li>
<li>writes one autosave snapshot if dirty</li>
</ul>
</li>
</ol>
<p><strong><em>Example</em></strong></p>
<p><pre class="listing"><span class="Identifier">transaction</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">hp</span> <span class="Operator">-=</span> <span class="DecNumber">10</span>
  <span class="Identifier">mana</span> <span class="Operator">-=</span> <span class="DecNumber">5</span>
  <span class="Identifier">inv</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="StringLit">&quot;potion&quot;</span>
<span class="Comment"># exactly one reaction run and one history record for inv</span></pre></p>
<p><strong><em>Nesting and exceptions</em></strong></p>
<ul class="simple"><li>Nested transactions simply increment the counter further; commit runs only when the outermost layer finishes.</li>
<li>The template uses <tt class="docutils literal"><span class="pre"><span class="Keyword">try</span><span class="Operator">/</span><span class="Keyword">finally</span></span></tt> so <tt class="docutils literal"><span class="pre"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">batching</span></span></tt> is decremented even if <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> raises. An exception aborts the commit; partial changes stay applied because the engine has no automatic rollback. Call <tt class="docutils literal"><span class="pre"><span class="Identifier">undo</span></span></tt> in a custom catch block if you need an all-or-nothing effect.</li>
</ul>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Blocking <tt class="docutils literal"><span class="pre"><span class="Identifier">flushQueued</span><span class="Punctuation">(</span><span class="Identifier">ctx</span><span class="Punctuation">)</span></span></tt> inside the same frame when using a frame scheduler negates batching benefits.</li>
<li>Long running code inside <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> can delay reactions longer than users expect.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="val-templates-all">
  <div id="val.t,Signal">
  <dt><pre><span class="Keyword">template</span> <a href="#val.t%2CSignal"><span class="Identifier">val</span></a><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <a href="signals.html#Signal"><span class="Identifier">Signal</span></a><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
  <dd>
    
    <p>Expands to <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">value</span></span></tt> and performs dependency tracking.</p>
<p>When this template is used inside <tt class="docutils literal"><span class="pre"><span class="Identifier">effect</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">computed</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">memo</span></span></tt>, or <tt class="docutils literal"><span class="pre"><span class="Identifier">watch</span></span></tt> the call runs through <tt class="docutils literal"><span class="pre"><span class="Identifier">registerDep</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span></span></tt> first. That records the <strong>current observer callback</strong> as a subscriber of the signal, so any future <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt> on the same signal will schedule the observer to run again.</p>
<p><strong><em>Relationship to other helpers</em></strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">val</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span></span></tt>  (this template)  -&gt; read <strong>and</strong> track</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">peek</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span></span></tt> -&gt; read <strong>without</strong> tracking</li>
</ul>
<p>Choose <tt class="docutils literal"><span class="pre"><span class="Identifier">val</span></span></tt> when you want reactivity; choose <tt class="docutils literal"><span class="pre"><span class="Identifier">peek</span></span></tt> when you only need the value once during the current execution.</p>
<p><strong><em>Typical pattern</em></strong></p>
<p><pre class="listing"><span class="Identifier">ctx</span><span class="Operator">.</span><span class="Identifier">effect</span> <span class="Keyword">proc</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;HP:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">hp</span><span class="Operator">.</span><span class="Identifier">val</span><span class="Punctuation">,</span> <span class="StringLit">&quot;/&quot;</span><span class="Punctuation">,</span> <span class="Identifier">maxHp</span><span class="Operator">.</span><span class="Identifier">val</span>   <span class="Comment"># both reads tracked</span></pre></p>
<p><strong><em>Pitfalls</em></strong></p>
<ul class="simple"><li>Calling <tt class="docutils literal"><span class="pre"><span class="Identifier">val</span></span></tt> outside an observer context (for example in plain top-level code) still works but adds no subscription; if the read must stay reactive place it in an effect or computed signal.</li>
<li>Reading inside a loop in an effect collects a dependency for every iteration. If the loop length can grow unbounded this may create a large subscriber list; consider using structural signals like <tt class="docutils literal"><span class="pre"><span class="Identifier">rev</span><span class="Punctuation">(</span><span class="Identifier">rs</span><span class="Punctuation">)</span></span></tt> instead.</li>
</ul>

    
  </dd>
</div>

</div>
<div id="watchNow-templates-all">
  <div id="watchNow.t,ReactiveCtx,,proc(T,T)">
  <dt><pre><span class="Keyword">template</span> <a href="#watchNow.t%2CReactiveCtx%2C%2Cproc%28T%2CT%29"><span class="Identifier">watchNow</span></a><span class="Other">[</span><span class="Identifier">T</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <a href="signals.html#ReactiveCtx"><span class="Identifier">ReactiveCtx</span></a><span class="Other">;</span> <span class="Identifier">selector</span><span class="Other">:</span> <span class="Other">(</span><span class="Other">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">T</span><span class="Other">;</span>
                     <span class="Identifier">handler</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">newVal</span><span class="Other">,</span> <span class="Identifier">oldVal</span><span class="Other">:</span> <span class="Identifier">T</span><span class="Other">)</span><span class="Other">)</span></pre></dt>
  <dd>
    
    <p>Shorthand for <tt class="docutils literal"><span class="pre"><span class="Identifier">watch</span></span></tt> with <tt class="docutils literal"><span class="pre"><span class="Identifier">immediate</span> <span class="Operator">=</span> <span class="Identifier">true</span></span></tt>. Runs <tt class="docutils literal"><span class="pre"><span class="Identifier">selector</span></span></tt> immediately, stores the result, invokes <tt class="docutils literal"><span class="pre"><span class="Identifier">handler</span><span class="Punctuation">(</span><span class="Identifier">new</span><span class="Punctuation">,</span> <span class="Identifier">new</span><span class="Punctuation">)</span></span></tt> once, and then behaves like <tt class="docutils literal"><span class="pre"><span class="Identifier">watch</span></span></tt>, calling <tt class="docutils literal"><span class="pre"><span class="Identifier">handler</span><span class="Punctuation">(</span><span class="Identifier">new</span><span class="Punctuation">,</span> <span class="Identifier">old</span><span class="Punctuation">)</span></span></tt> whenever the selectorâ€™s output changes.</p>
<p>Helpful for loading indicators or log statements that should fire right away and on every subsequent change without writing two separate calls.</p>

    
  </dd>
</div>

</div>

  </dl>
</div>

  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2025-05-16 16:05:01 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
